// const createGraph = require('ngraph.graph')
// const updateGraph = require('./update-graph')
// const iterateLayout = require('./iterate-layout')
const mapValues = require('lodash.mapvalues')
const testState = require('state')
const debug = require('debug')('graph:reducers')
const extend = require('xtend')
const ITERATIONS = 200
const width = 960
const height = 500

import { find, some, each, groupBy } from 'lodash'
import {
  AGENT_GRAPH,
  GRAPH_TICK,
  UPDATE_NODES,
  UPDATE_ITERATIONS,
  GRAPH_START,
  UPDATE_GRAPH,
  UPDATE_LAYOUT } from 'action-types'

import { getQueriesById } from './getters.js'
import { relationshipsByAgentId } from 'relationship/getters'
import { agentsById } from 'agent/getters'
import queryReducer from 'query/reducers'
import Cola from 'webcola'
import { indexBy, clone } from 'lodash'

const findQuery = (relationship, queries, agentId) => {
  return find(queries, query => {
    return relationship.type === query.relationshipType &&
      relationship[query.direction] === agentId
  })
}

const makeLink = (relationshipType, source, target) => {
  return {
    relationshipType: relationshipType,
    //relationshipId: relationship.id,
    source: source,
    target: target
  }
}



const singleQueryLayout = (state, contextAgentId, queries) => {
  let agents = agentsById(state)
  let nodeToIndex = {}
  let nodes = []
  let links = []

  each(relationshipsByAgentId(state)[contextAgentId], relationship => {
    let query = findQuery(relationship, queries, contextAgentId)
    if (query) {
      ;['source', 'target'].forEach(direction => {
        if (!nodeToIndex[relationship[direction]]) {
          nodeToIndex[relationship[direction]] = nodes.length
          nodes.push(agents[relationship[direction]])
        }
      })
      links.push(extend(relationship, {
        source: nodeToIndex[relationship.source],
        target: nodeToIndex[relationship.target]
      }))
    }
  })

  return { nodes, links, groups: [] }
}

const mutipleQueriesLayout = (state, contextAgentId, queries) => {
  let agents = agentsById(state)
  let relationships = relationshipsByAgentId(state)
  let queriesById = indexBy(queries, 'id') 
  let nodeToIndex = {}
  let queryToNodes = {}
  let queryToGroupIndex = {}
  let nodeToGroup = {}
  let nodes = []
  let links = []
  let groups = []

  const switchDirection = direction => {
    return direction === 'target' ? 'source' : 'target'
  }


  debug('queries', queries)

  // find active nodes and join their links and queries
  each(relationships[contextAgentId], relationship => {
    let query = findQuery(relationship, queries, contextAgentId)
    if (query) {
      each(['source', 'target'], direction => {
        if (!nodeToIndex[relationship[direction]]) {
          nodeToIndex[relationship[direction]] = nodes.length
          let agent = agents[relationship[direction]]
          nodes.push({
            ...agent,
            display: true,
            outLinks: [],
            inLinks: [],
            queries: [],
            groups: []
          })
        }
      })

      let link = {
        type: 'mid',
        relationshipType: relationship.type,
        source: nodeToIndex[relationship.source],
        target: nodeToIndex[relationship.target]
      }

      debug('link', link)
      nodes[nodeToIndex[relationship.source]].outLinks.push(link)
      nodes[nodeToIndex[relationship.target]].inLinks.push(link)
      nodes[nodeToIndex[relationship.source]].queries.push(query)
      nodes[nodeToIndex[relationship.target]].queries.push(query)
    }
  })

  each(nodes, node => {
    if (node.queries.length === 1) {
      // nodes that match 1 query grouped together with same query nodes
      let queryId = node.queries[0].id
      if (!queryToNodes[queryId]) { queryToNodes[queryId] = [] }
      queryToNodes[queryId].push(node.id)
    }
  })

  each(queryToNodes, (queryNodes, queryId) => {
    if (queryNodes.length > 1) {
      let node = nodes[nodeToIndex[queryNodes[0]]]
      let query = queriesById[queryId]
      let direction = query.direction
      
      
      
      let outLinks = clone(node.outLinks)
      let inLinks = clone(node.inLinks)
      
      



      debug('queriesById', queriesById, node, queryId)
      let group = { nodes: [] }

      nodeToIndex[queryId] = nodes.length
      nodes.push({
        display: false,
        type: 'groupNode',
        outLinks: [],
        inLinks: [],
        groups: [],
        query: queryId
      })

      let groupLink = { type: 'long' }
      groupLink[direction] = nodeToIndex[contextAgentId]
      groupLink[switchDirection(direction)] = nodes.length - 1
      groupLink.relationshipType = query.relationshipType
      debug('groupLink', groupLink, nodes[groupLink.source])
      
      
      nodes[groupLink.source].outLinks.push(groupLink)
      nodes[groupLink.target].inLinks.push(groupLink)

      each(queryNodes, nodeId => {
        nodeToGroup[nodeId] = true
        // add grouped nodes to fake node
        //   nodes[nodeToIndex[queryId]].inLinks.push(nodeToIndex[nodeId])
        nodes[nodeToIndex[nodeId]].groups.push(queryId)
      
        nodes[nodeToIndex[nodeId]].outLinks = [{
          type: 'short',
          source: nodeToIndex[nodeId],
          target: nodes.length - 1,
          relationshipType: query.relationshipType
        }]
        nodes[nodeToIndex[nodeId]].inLinks = []
      })
    }
  })

  each(nodes, node => {
    debug('node', node)
    each(node.outLinks, link => {
      //debug('link', link)
      links.push(link)

    // each(node.inLinks, link => {
    //   let groupedNode = !nodeToGroup[node.id]
    //   links.push({
    //     ...link,
    //     display: groupedNode, // hide links from grouped nodes
    //     type: groupedNode ? 'fromGroupedNode' : 'fromUngroupedNode'
    //   })
     })
  })

  debug('groups', groups)
  debug('links', links)
  debug('nodes', nodes)

  return { nodes, links, groups }
}

const linkDistance = idealLength => link => {
  switch (link.type) {
    case 'short':
      return idealLength * 0.8
    case 'long':
      return idealLength * 1.2
    default:
      return idealLength
  }
}


const Layout = (state, contextAgentId, queries) => {
  const layout = new Cola.Layout()
  const { nodes, links, groups } = queries.length === 1
    ? singleQueryLayout(state, contextAgentId, queries)
    : mutipleQueriesLayout(state, contextAgentId, queries)

  debug('groups', groups)

  layout
    .linkDistance(linkDistance(100))
    .avoidOverlaps(true)
    .handleDisconnected(false)
    .size([width, height])
    .nodes(nodes)
    .links(links)
    // .groups(groups)
    // .start()

  return {
    layout,
    nodes,
    links,
    groups
  }
}

const agentGraph = (state, action) => {
  debug('agentGraph', action)
  const agentId = action.payload
  const queries = queryReducer(state, action)
  const { layout, nodes, links, groups } = Layout(state, agentId, queries)
  const layoutIsUpdating = false
  const iterations = 200
  const iterationsCount = 0

  debug('layout', nodes)
  return {
    layout, nodes, links, groups, iterations, iterationsCount, agentId,
    queries,
    layoutIsUpdating
  }
}

// const onUpdatingLayout = (state, action) => {
//   debug('startLayoutUpdate')
//   return {
//    ...state.graph,
//    updatingLayout: action.payload // boolean
//   }
// }

const onUpdatingLayout = (state, action) => {
  debug('onUpdatingLayout', action)

  const layout = action.payload
  const layoutIsUpdating = true

  return {
    ...state.graph,
    layout,
    layoutIsUpdating
  }
}

const onUpdateIterations = (state, action) => {
  return {
    ...state.graph,
    iterationsCount: action.payload
  }
}


const onUpdateNodes = (state, action) => {
  debug('onUpdateNodes', action.payload[0].x)
  return {
    ...state.graph,
    nodes: action.payload.map(node => {
      return {
        ...node,
        x: node.x,
        y: node.y
      }
    })
  }
}


const graphReducers = {}
graphReducers[AGENT_GRAPH] = agentGraph
graphReducers[UPDATE_ITERATIONS] = onUpdateIterations
graphReducers[UPDATE_LAYOUT] = onUpdatingLayout
graphReducers[UPDATE_NODES] = onUpdateNodes




export const graphReducer = (state = testState, action) => {
  debug('graphReducer', action)
  if (!graphReducers[action.type]) {
    return state.graph
  } else {
    return graphReducers[action.type](state, action)
  }
}
