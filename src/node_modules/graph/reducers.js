// const createGraph = require('ngraph.graph')
// const updateGraph = require('./update-graph')
// const iterateLayout = require('./iterate-layout')
const mapValues = require('lodash.mapvalues')
const testState = require('state')
const debug = require('debug')('graph:reducers')
const extend = require('xtend')
const ITERATIONS = 50

import { find, some, each, groupBy } from 'lodash'
import { AGENT_GRAPH, GRAPH_TICK, GRAPH_START } from 'action-types'
import { relationshipsByAgentId } from 'relationship/getters'
import { agentsById } from 'agent/getters'
import queryReducer from 'query/reducers'
import Cola from 'webcola'
// import Adaptor from './webcola-adaptor'


const findQuery = (relationship, queries, agentId) => {
  return find(queries, query => {
    return relationship.type === query.relationshipType &&
      relationship[query.direction] === agentId
  })
}


const singleQueryLayout = (state, contextAgentId, queries) => {
  let agents = agentsById(state)
  let nodeToIndex = {}
  let nodes = []
  let links = []

  each(relationshipsByAgentId(state)[contextAgentId], relationship => {
    let query = findQuery(relationship, queries, contextAgentId)
    if (query) {
      ;['source', 'target'].forEach(direction => {
        if (!nodeToIndex[relationship[direction]]) {
          nodeToIndex[relationship[direction]] = nodes.length
          nodes.push(agents[relationship[direction]])
        }
      })
      links.push(extend(relationship, {
        source: nodeToIndex[relationship.source],
        target: nodeToIndex[relationship.target]
      }))
    }
  })

  return [nodes, links, []]
}

const mutipleQueriesLayout = (state, contextAgentId, queries) => {
  let agents = agentsById(state)
  let nodeToIndex = {}
  let queryToNodes = {}
  let queryToGroupIndex = {}
  let nodeToGroup = {}
  let nodes = []
  let links = []
  let groups = []

  // find active nodes and join their links and queries
  each(relationshipsByAgentId(state)[contextAgentId], relationship => {
    let query = findQuery(relationship, queries, contextAgentId)
    if (query) {
      each(['source', 'target'], direction => {
        if (!nodeToIndex[relationship[direction]]) {
          nodeToIndex[relationship[direction]] = nodes.length
          nodes.push(extend(agents[relationship[direction]], {
            outLinks: [],
            inLinks: [],
            queries: [],
            groups: []
          }))
        }
      })

      let link = extend(relationship, {
        source: nodeToIndex[relationship.source],
        target: nodeToIndex[relationship.target]
      })

      nodes[nodeToIndex[relationship.source]].outLinks.push(link)
      nodes[nodeToIndex[relationship.target]].inLinks.push(link)
      nodes[nodeToIndex[relationship.source]].queries.push(query)
      nodes[nodeToIndex[relationship.target]].queries.push(query)
    }
  })

  // add queries as hidden nodes, build links to contextAgent
  // each(queries, query => {
  //   nodeToIndex[query.id] = nodes.length
  //   links.push(extend(query, {
  //     source: nodes.length,
  //     target: nodeToIndex[contextAgentId]
  //   }))
  //   nodes.push(extend(query, { display: false })
  // })

  each(nodes, node => {
    if (node.queries.length === 1) {
      // nodes that match 1 query grouped together with same query nodes
      let queryId = node.queries[0].id

      if (!queryToNodes[queryId]) {
        queryToNodes[queryId] = []
      }

      queryToNodes[queryId].push(node.id)
    }
  })

  each(queryToNodes, (nodes, queryId) => {
    if (nodes.length > 1) {
      let group = { leaves: [] }

      each(nodes, node => {
        nodeToGroup[node.id] = true
        debug('nodeToIndex', nodeToIndex, node, nodeToIndex[node])
        // debugger
        group.leaves.push(nodeToIndex[node])
      })

      groups.push(group)

    }
  })

  each(nodes, node => {
    each(node.outLinks, link => {
      links.push(extend(link, { display: !nodeToGroup[node.id] })) // hide links from grouped nodes
    })
  })

  debug('groups', groups)
  debug('links', links)
  debug('nodes', nodes)

  return [nodes, links, groups]
}


const Layout = (state, contextAgentId, queries) => {
  let layout = new Cola.Layout()
  let graphComponents = queries.length === 1 ?
    singleQueryLayout(state, contextAgentId, queries) :
    mutipleQueriesLayout(state, contextAgentId, queries)
  debug('groups', graphComponents[2])

  // layout.size([500, 500])
  // layout.convergenceThreshold(0.001)
  layout
    .avoidOverlaps(true)
    .defaultNodeSize(40)
    .linkDistance(120)
    .convergenceThreshold(0.01)
    // .nodes(graphComponents[0])
    // .links(graphComponents[1])
    // .groups(graphComponents[2])
    // .start()

  return {
    layout: layout,
    nodes: graphComponents[0],
    links: graphComponents[1],
    groups: graphComponents[2]
  }
}

const agentGraph = (state, action) => {
  let queries = queryReducer(state, action)
  let layout = Layout(state, action.payload, queries)
  let nodes = layout.layout.nodes()
  let updatingLayout = false

  debug('layout', nodes)
  return {
    ...layout,
    queries,
    updatingLayout
  }
}

const startLayoutUpdate = (state, action) => {
  debug('startLayoutUpdate')
  return {
   ...state.graph,
   updatingLayout: true
  }
}

const onGraphTick = (state, action) => {
  debug('onGraphTick', action.payload[0].x)
  return {
    ...state.graph,
    nodes: [ ...action.payload ]
  }
}

const graphReducers = {}
graphReducers[AGENT_GRAPH] = agentGraph
graphReducers[GRAPH_START] = startLayoutUpdate
graphReducers[GRAPH_TICK] = onGraphTick

export const graphReducer = (state = testState, action) => {
  if (!graphReducers[action.type]) {
    return state.graph
  } else {
    return graphReducers[action.type](state, action)
  }
}
