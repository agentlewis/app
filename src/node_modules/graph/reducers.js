// const createGraph = require('ngraph.graph')
// const updateGraph = require('./update-graph')
// const iterateLayout = require('./iterate-layout')
const mapValues = require('lodash.mapvalues')
const testState = require('state')
const debug = require('debug')('graph:reducers')
const extend = require('xtend')
const ITERATIONS = 200
const width = 960
const height = 500
const R = require('ramda')
import { find, some, each, groupBy } from 'lodash'
import {
  AGENT_GRAPH,
  AGENT_GRAPH_ID,
  GRAPH_TICK,
  UPDATE_NODES,
  UPDATE_NODES_END,
  UPDATE_ITERATIONS,
  GRAPH_START,
  UPDATE_GRAPH,
  UPDATE_LAYOUT } from 'action-types'

import { getLayout } from './getters'  
import { getQueriesById, getQueries } from 'query/getters.js'
import { getAgentGraphId } from 'agent/getters'
import { relationshipsByAgentId } from 'relationship/getters'
import { agentsById } from 'agent/getters'
import Cola from 'webcola'
import { indexBy, clone } from 'lodash'

const linkDistance = idealLength => link => {
  switch (link.type) {
    case 'short':
      return idealLength * 0.8
    case 'long':
      return idealLength * 1.2
    default:
      return idealLength
  }
}

const switchDirection = direction => {
  return direction === 'target' ? 'source' : 'target'
}

const findQuery = (relationship, queries, agentId) => {
  return find(queries, query => {
    return relationship.type === query.relationshipType &&
      relationship[query.direction] === agentId
  })
}

const makeLink = (relationshipType, source, target) => {
  return {
    relationshipType: relationshipType,
    //relationshipId: relationship.id,
    source: source,
    target: target
  }
}

const singleQueryLayout = (state, contextAgentId, queries) => {
  let agents = agentsById(state)
  let nodeToIndex = {}
  let nodes = []
  let links = []

  each(relationshipsByAgentId(state)[contextAgentId], relationship => {
    let query = findQuery(relationship, queries, contextAgentId)
    if (query) {
      ;['source', 'target'].forEach(direction => {
        if (!nodeToIndex[relationship[direction]]) {
          nodeToIndex[relationship[direction]] = nodes.length
          nodes.push(agents[relationship[direction]])
        }
      })
      links.push(extend(relationship, {
        source: nodeToIndex[relationship.source],
        target: nodeToIndex[relationship.target]
      }))
    }
  })

  return { nodes, links, groups: [] }
}

const mutipleQueriesLayout = (state, contextAgentId, queries) => {
  let agents = agentsById(state)
  let relationships = relationshipsByAgentId(state)
  let queriesById = getQueriesById(state)
  let nodeToIndex = {}
  let queryToNodes = {}
  let queryToGroupIndex = {}
  let nodeToGroup = {}
  let nodes = []
  let links = []
  let groups = []
  debug('queries', queries, queriesById)

  // find active nodes and join their links and queries
  each(relationships[contextAgentId], relationship => {
    let query = findQuery(relationship, queries, contextAgentId)
    if (query) {
      each(['source', 'target'], direction => {
        if (!nodeToIndex[relationship[direction]]) {
          nodeToIndex[relationship[direction]] = nodes.length
          let agent = agents[relationship[direction]]
          nodes.push({
            ...agent,
            display: true,
            outLinks: [],
            inLinks: [],
            queries: [],
            groups: []
          })
        }
      })

      let link = {
        type: 'mid',
        relationshipType: relationship.type,
        source: nodeToIndex[relationship.source],
        target: nodeToIndex[relationship.target]
      }

      debug('link', link)
      nodes[nodeToIndex[relationship.source]].outLinks.push(link)
      nodes[nodeToIndex[relationship.target]].inLinks.push(link)
      nodes[nodeToIndex[relationship.source]].queries.push(query)
      nodes[nodeToIndex[relationship.target]].queries.push(query)
    }
  })

  each(nodes, node => {
    if (node.queries.length === 1) {
      // nodes that match 1 query grouped together with same query nodes
      let queryId = node.queries[0].id
      if (!queryToNodes[queryId]) { queryToNodes[queryId] = [] }
      queryToNodes[queryId].push(node.id)
    }
  })

  each(queryToNodes, (queryNodes, queryId) => {
    if (queryNodes.length > 1) {
      let node = nodes[nodeToIndex[queryNodes[0]]]
      let query = queriesById[queryId]
      debug('queriesById', queriesById, queryId)
      
      let direction = query.direction
      let outLinks = clone(node.outLinks)
      let inLinks = clone(node.inLinks)

      debug('queriesById', queriesById, node, queryId)
      let group = { nodes: [] }

      nodeToIndex[queryId] = nodes.length
      nodes.push({
        display: false,
        type: 'groupNode',
        outLinks: [],
        inLinks: [],
        groups: [],
        query: queryId
      })

      let groupLink = { type: 'long' }
      groupLink[direction] = nodeToIndex[contextAgentId]
      groupLink[switchDirection(direction)] = nodes.length - 1
      groupLink.relationshipType = query.relationshipType
      debug('groupLink', groupLink, nodes[groupLink.source])
      
      
      nodes[groupLink.source].outLinks.push(groupLink)
      nodes[groupLink.target].inLinks.push(groupLink)

      each(queryNodes, nodeId => {
        nodeToGroup[nodeId] = true
        nodes[nodeToIndex[nodeId]].groups.push(queryId)
      
        nodes[nodeToIndex[nodeId]].outLinks = [{
          type: 'short',
          source: nodeToIndex[nodeId],
          target: nodes.length - 1,
          relationshipType: query.relationshipType
        }]
        nodes[nodeToIndex[nodeId]].inLinks = []
      })
    }
  })

  each(nodes, node => {
    each(node.outLinks, link => {
      links.push(link)
     })
  })

  debug('groups', groups)
  debug('links', links)
  debug('nodes', nodes)

  return { nodes, links, groups }
}

const Layout = (state, contextAgentId, queries) => {
  const nodesAndLinks = queries.length === 1
    ? singleQueryLayout(state, contextAgentId, queries)
    : queries.length > 1 
      ? mutipleQueriesLayout(state, contextAgentId, queries)
      : null

  if (nodesAndLinks) {
    const { nodes, links, groups } = nodesAndLinks    
    const layout = new Cola.Layout()

    layout
      .linkDistance(linkDistance(100))
      .avoidOverlaps(true)
      .handleDisconnected(false)
      .size([width, height])
      .nodes(nodes)
      .links(links)

    return layout
  } else {
    return null
  }
}

export const graphLayoutReducer = (state, action) => {
  debug('graphLayoutReducer', action)
  const agentId = getAgentGraphId(state)
  const queries = getQueries(state)
  debug('queries', agentId, queries)
  return (agentId && queries) ? Layout(state, agentId, queries) : null
}

export const agentGraphId = (state, action) => {
  debug('agentGraphId', action.type, state) 
  if (action.type === AGENT_GRAPH_ID) {
    return  action.payload
  } else {
    return state.agentGraphId
  }
}

export const nodesFromLayout = (state, action) => {
  const layout = getLayout(state)
  if (layout) { return layout.nodes() }
  else { return null }
}

export const linksFromLayout = (state, action) => {
  const layout = getLayout(state)
  if (layout) { return layout.links() }
  else { return null }
}

const onUpdatingLayout = (state, action) => {
  debug('onUpdatingLayout', action)
  const layout = action.payload
  const layoutIsUpdating = true

  return {
    ...state.graph,
    layout,
    layoutIsUpdating
  }
}

const onUpdateIterations = (state, action) => {
  return {
    ...state.graph,
    iterationsCount: action.payload
  }
}

const onUpdateNodes = (state, action) => {
  debug('onUpdateNodes', action.payload[0].x)
  return Object.assign({}, state.graph, {
    nodes: R.map(node => {
      return Object.assign({}, node, {
        x: node.x,
        y: node.y
      })
    }, action.payload),
    shouldUpdate: true
  })
}

const updateNodesEnd = (state, action) => {
  return {
    ...state.graph,
    shouldUpdate: false
  }
}


const graphReducers = {}
graphReducers[AGENT_GRAPH] = graphLayoutReducer

// graphReducers[AGENT_GRAPH_ID] = agentGraphId
graphReducers[UPDATE_ITERATIONS] = onUpdateIterations 

graphReducers[UPDATE_LAYOUT] = onUpdatingLayout 

graphReducers[UPDATE_NODES] = onUpdateNodes

graphReducers[UPDATE_NODES_END] = updateNodesEnd

export const graphReducer = (state = testState, action) => {
  debug('graphReducer', action)
  if (!action || !graphReducers[action.type]) {
    return state.graph
  } else {
    return graphReducers[action.type](state, action)
  }
}
