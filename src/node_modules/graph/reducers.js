// const createGraph = require('ngraph.graph')
// const updateGraph = require('./update-graph')
// const iterateLayout = require('./iterate-layout')
const mapValues = require('lodash.mapvalues')
const testState = require('state')
const debug = require('debug')('graph:reducers')
const extend = require('xtend')
const ITERATIONS = 200
const width = 960
const height = 500

import { find, some, each, groupBy } from 'lodash'
import {
  AGENT_GRAPH,
  GRAPH_TICK,
  UPDATE_NODES,
  UPDATE_ITERATIONS,
  GRAPH_START,
  UPDATE_GRAPH,
  UPDATE_LAYOUT } from 'action-types'


import { relationshipsByAgentId } from 'relationship/getters'
import { agentsById } from 'agent/getters'
import queryReducer from 'query/reducers'
import Cola from 'webcola'

const findQuery = (relationship, queries, agentId) => {
  return find(queries, query => {
    return relationship.type === query.relationshipType &&
      relationship[query.direction] === agentId
  })
}

const singleQueryLayout = (state, contextAgentId, queries) => {
  let agents = agentsById(state)
  let nodeToIndex = {}
  let nodes = []
  let links = []

  each(relationshipsByAgentId(state)[contextAgentId], relationship => {
    let query = findQuery(relationship, queries, contextAgentId)
    if (query) {
      ;['source', 'target'].forEach(direction => {
        if (!nodeToIndex[relationship[direction]]) {
          nodeToIndex[relationship[direction]] = nodes.length
          nodes.push(agents[relationship[direction]])
        }
      })
      links.push(extend(relationship, {
        source: nodeToIndex[relationship.source],
        target: nodeToIndex[relationship.target]
      }))
    }
  })

  return { nodes, links, groups: [] }
}

const mutipleQueriesLayout = (state, contextAgentId, queries) => {
  let agents = agentsById(state)
  let nodeToIndex = {}
  let queryToNodes = {}
  let queryToGroupIndex = {}
  let nodeToGroup = {}
  let nodes = []
  let links = []
  let groups = []

  // find active nodes and join their links and queries
  each(relationshipsByAgentId(state)[contextAgentId], relationship => {
    let query = findQuery(relationship, queries, contextAgentId)
    if (query) {
      each(['source', 'target'], direction => {
        if (!nodeToIndex[relationship[direction]]) {
          nodeToIndex[relationship[direction]] = nodes.length
          nodes.push(extend(agents[relationship[direction]], {
            outLinks: [],
            inLinks: [],
            queries: [],
            groups: []
          }))
        }
      })

      let link = extend(relationship, {
        source: nodeToIndex[relationship.source],
        target: nodeToIndex[relationship.target]
      })

      nodes[nodeToIndex[relationship.source]].outLinks.push(link)
      nodes[nodeToIndex[relationship.target]].inLinks.push(link)
      nodes[nodeToIndex[relationship.source]].queries.push(query)
      nodes[nodeToIndex[relationship.target]].queries.push(query)
    }
  })

  // add queries as hidden nodes, build links to contextAgent
  // each(queries, query => {
  //   nodeToIndex[query.id] = nodes.length
  //   links.push(extend(query, {
  //     source: nodes.length,
  //     target: nodeToIndex[contextAgentId]
  //   }))
  //   nodes.push(extend(query, { display: false })
  // })

  each(nodes, node => {
    if (node.queries.length === 1) {
      // nodes that match 1 query grouped together with same query nodes
      let queryId = node.queries[0].id

      if (!queryToNodes[queryId]) {
        queryToNodes[queryId] = []
      }

      queryToNodes[queryId].push(node.id)
    }
  })

  each(queryToNodes, (nodes, queryId) => {
    if (nodes.length > 1) {
      let group = { leaves: [] }

      each(nodes, node => {
        nodeToGroup[node.id] = true
        debug('nodeToIndex', nodeToIndex, node, nodeToIndex[node])
        // debugger
        group.leaves.push(nodeToIndex[node])
      })

      groups.push(group)

    }
  })

  each(nodes, node => {
    each(node.outLinks, link => {
      links.push(extend(link, { display: !nodeToGroup[node.id] })) // hide links from grouped nodes
    })
  })

  debug('groups', groups)
  debug('links', links)
  debug('nodes', nodes)

  return { nodes, links, groups }
}


const Layout = (state, contextAgentId, queries) => {
  const layout = new Cola.Layout()
  const { nodes, links, groups } = queries.length === 1
    ? singleQueryLayout(state, contextAgentId, queries)
    : mutipleQueriesLayout(state, contextAgentId, queries)

  debug('groups', groups)

  // layout.size([500, 500])
  // layout.convergenceThreshold(0.001)
  layout
    .linkDistance(100)
    .avoidOverlaps(true)
    .handleDisconnected(false)
    .size([width, height])
    .nodes(nodes)
    .links(links)
    .groups(groups)
    // .start()

  return {
    layout,
    nodes,
    links,
    groups
  }
}

const agentGraph = (state, action) => {
  debug('agentGraph', action)
  const agentId = action.payload
  const queries = queryReducer(state, action)
  const { layout, nodes, links, groups } = Layout(state, agentId, queries)
  const layoutIsUpdating = false
  const iterations = 200
  const iterationsCount = 0



  debug('layout', nodes)
  return {
    layout, nodes, links, groups, iterations, iterationsCount, agentId,
    queries,
    layoutIsUpdating
  }
}

// const onUpdatingLayout = (state, action) => {
//   debug('startLayoutUpdate')
//   return {
//    ...state.graph,
//    updatingLayout: action.payload // boolean
//   }
// }

const onUpdatingLayout = (state, action) => {
  debug('onUpdatingLayout', action)

  const layout = action.payload
  const layoutIsUpdating = true

  return {
    ...state.graph,
    layout,
    layoutIsUpdating
  }
}

const onUpdateIterations = (state, action) => {
  return {
    ...state.graph,
    iterationsCount: action.payload
  }
}


const onUpdateNodes = (state, action) => {
  debug('onUpdateNodes', action.payload[0].x)
  return {
    ...state.graph,
    nodes: action.payload.map(node => {
      return {
        ...node,
        x: node.x,
        y: node.y
      }
    })
  }
}


const graphReducers = {}
graphReducers[AGENT_GRAPH] = agentGraph
graphReducers[UPDATE_ITERATIONS] = onUpdateIterations
graphReducers[UPDATE_LAYOUT] = onUpdatingLayout
graphReducers[UPDATE_NODES] = onUpdateNodes




export const graphReducer = (state = testState, action) => {
  debug('graphReducer', action)
  if (!graphReducers[action.type]) {
    return state.graph
  } else {
    return graphReducers[action.type](state, action)
  }
}
