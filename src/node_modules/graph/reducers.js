// const createGraph = require('ngraph.graph')
// const updateGraph = require('./update-graph')
// const iterateLayout = require('./iterate-layout')
const mapValues = require('lodash.mapvalues')
const testState = require('state')
const debug = require('debug')('graph:reducers')
const extend = require('xtend')
const ITERATIONS = 200
const width = 960
const height = 500

import { find, some, each, groupBy } from 'lodash'
import {
  AGENT_GRAPH,
  GRAPH_TICK,
  UPDATE_NODES,
  UPDATE_ITERATIONS,
  GRAPH_START,
  UPDATE_GRAPH,
  UPDATE_LAYOUT } from 'action-types'


import { relationshipsByAgentId } from 'relationship/getters'
import { agentsById } from 'agent/getters'
import queryReducer from 'query/reducers'
import Cola from 'webcola'

const findQuery = (relationship, queries, agentId) => {
  return find(queries, query => {
    return relationship.type === query.relationshipType &&
      relationship[query.direction] === agentId
  })
}

const singleQueryLayout = (state, contextAgentId, queries) => {
  let agents = agentsById(state)
  let nodeToIndex = {}
  let nodes = []
  let links = []

  each(relationshipsByAgentId(state)[contextAgentId], relationship => {
    let query = findQuery(relationship, queries, contextAgentId)
    if (query) {
      ;['source', 'target'].forEach(direction => {
        if (!nodeToIndex[relationship[direction]]) {
          nodeToIndex[relationship[direction]] = nodes.length
          nodes.push(agents[relationship[direction]])
        }
      })
      links.push(extend(relationship, {
        source: nodeToIndex[relationship.source],
        target: nodeToIndex[relationship.target]
      }))
    }
  })

  return { nodes, links, groups: [] }
}

const mutipleQueriesLayout = (state, contextAgentId, queries) => {
  let agents = agentsById(state)
  let relationships = relationshipsByAgentId(state)
  let nodeToIndex = {}
  let queryToNodes = {}
  let queryToGroupIndex = {}
  let nodeToGroup = {}
  let nodes = []
  let links = []
  let groups = []

  // find active nodes and join their links and queries
  each(relationships[contextAgentId], relationship => {
    let query = findQuery(relationship, queries, contextAgentId)
    if (query) {
      each(['source', 'target'], direction => {
        if (!nodeToIndex[relationship[direction]]) {
          nodeToIndex[relationship[direction]] = nodes.length
          let agent = agents[relationship[direction]]
          nodes.push({
            ...agent,
            display: true,
            outLinks: [],
            inLinks: [],
            queries: [],
            groups: []
          })
        }
      })

      let link = { ...relationship,
        source: nodeToIndex[relationship.source],
        target: nodeToIndex[relationship.target]
      }

      nodes[nodeToIndex[relationship.source]].outLinks.push(link)
      nodes[nodeToIndex[relationship.target]].inLinks.push(link)
      nodes[nodeToIndex[relationship.source]].queries.push(query)
      nodes[nodeToIndex[relationship.target]].queries.push(query)
    }
  })

  each(nodes, node => {
    if (node.queries.length === 1) {
      // nodes that match 1 query grouped together with same query nodes
      let queryId = node.queries[0].id
      if (!queryToNodes[queryId]) { queryToNodes[queryId] = [] }
      queryToNodes[queryId].push(node.id)
    }
  })

  each(queryToNodes, (queryNodes, queryId) => {
    if (queryNodes.length > 1) {

      let group = { nodes: [] }



      nodeToIndex[queryId] = nodes.length
      nodes.push({
        display: false,
        type: 'groupNode',
        outLinks: [ { query: queryId, source: nodeToIndex[queryId] } ],
        inLinks: [],
        groups: [],
        query: queryId
      })

      each(queryNodes, nodeId => {
        nodeToGroup[nodeId] = true
        debug('nodeToIndex', nodeToIndex, nodeId, nodes[nodeToIndex[nodeId]])
        // debugger
        nodes[nodeToIndex[queryId]].inLinks.push(nodeToIndex[nodeId])
        nodes[nodeToIndex[nodeId]].groups.push(queryId)
      })




    }
  })

  each(nodes, node => {
    each(node.outLinks, link => {
      debug('link', link)
      let groupLink = node.groups.length > 0 || nodes[link.target].groups.length > 0
      links.push({
        ...link,
        display: groupLink, // hide links from grouped nodes
        type: groupLink ? 'groupLink' : 'normalLink'
      })
    })

    // each(node.inLinks, link => {
    //   let groupedNode = !nodeToGroup[node.id]
    //   links.push({
    //     ...link,
    //     display: groupedNode, // hide links from grouped nodes
    //     type: groupedNode ? 'fromGroupedNode' : 'fromUngroupedNode'
    //   })
    // })
  })

  debug('groups', groups)
  debug('links', links)
  debug('nodes', nodes)

  return { nodes, links, groups }
}

const linkDistance = idealLength => link => {
  if (link.type === 'groupLink') {
    return idealLength * 1.2
  } else {
    return idealLength * 0.8
  }
}


const Layout = (state, contextAgentId, queries) => {
  const layout = new Cola.Layout()
  const { nodes, links, groups } = queries.length === 1
    ? singleQueryLayout(state, contextAgentId, queries)
    : mutipleQueriesLayout(state, contextAgentId, queries)

  debug('groups', groups)

  layout
    .linkDistance(linkDistance(100))
    .avoidOverlaps(true)
    .handleDisconnected(false)
    .size([width, height])
    .nodes(nodes)
    .links(links)
    .groups(groups)
    // .start()

  return {
    layout,
    nodes,
    links,
    groups
  }
}

const agentGraph = (state, action) => {
  debug('agentGraph', action)
  const agentId = action.payload
  const queries = queryReducer(state, action)
  const { layout, nodes, links, groups } = Layout(state, agentId, queries)
  const layoutIsUpdating = false
  const iterations = 200
  const iterationsCount = 0



  debug('layout', nodes)
  return {
    layout, nodes, links, groups, iterations, iterationsCount, agentId,
    queries,
    layoutIsUpdating
  }
}

// const onUpdatingLayout = (state, action) => {
//   debug('startLayoutUpdate')
//   return {
//    ...state.graph,
//    updatingLayout: action.payload // boolean
//   }
// }

const onUpdatingLayout = (state, action) => {
  debug('onUpdatingLayout', action)

  const layout = action.payload
  const layoutIsUpdating = true

  return {
    ...state.graph,
    layout,
    layoutIsUpdating
  }
}

const onUpdateIterations = (state, action) => {
  return {
    ...state.graph,
    iterationsCount: action.payload
  }
}


const onUpdateNodes = (state, action) => {
  debug('onUpdateNodes', action.payload[0].x)
  return {
    ...state.graph,
    nodes: action.payload.map(node => {
      return {
        ...node,
        x: node.x,
        y: node.y
      }
    })
  }
}


const graphReducers = {}
graphReducers[AGENT_GRAPH] = agentGraph
graphReducers[UPDATE_ITERATIONS] = onUpdateIterations
graphReducers[UPDATE_LAYOUT] = onUpdatingLayout
graphReducers[UPDATE_NODES] = onUpdateNodes




export const graphReducer = (state = testState, action) => {
  debug('graphReducer', action)
  if (!graphReducers[action.type]) {
    return state.graph
  } else {
    return graphReducers[action.type](state, action)
  }
}
