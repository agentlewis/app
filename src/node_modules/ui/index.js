var React = require('react')
var r = require('r-dom')
var debug = require('debug')('ui:index')
var each = require('lodash.foreach')
var reduce = require('lodash.reduce')
var clone = require('lodash.clone')
var contains = require('lodash.contains')
var types = require('types')
var Layout = require('layout')
var extend = require('xtend')
var Icon = require('./icons')
var style = require('./style')
var animateGraph = require('animate/animate-graph')
var formatGraphData = require('graph-view/format-graph-data')
var vars = require('ui/vars')
var Cola = require('graph-view/webcola-adaptor')()

function areFiltersSet (filtersByType) {
  return (filtersByType.context.length > 0 || filtersByType.targetAgent.length > 0)
}

function ensurePostioning (model, nodes) {
  if (model['@type'] === 'Group' && model.parentGroups.length > 0) {
    return nodes.reduce(function (memo, node) {
      if (model.parentGroups[0].getId() === node.id) { node.y = 0 } //assumes 1 parent
      memo.push(node)
      return memo
    }, [])
  }
  else {
    return nodes
  }
}

var FourOhFourPage = require('./404')

module.exports = React.createClass({
  getInitialState: function () {
    var filtersByType  = this.props.model.filtersByType
    var width = vars.graphSize.width
    var height = vars.graphSize.height
    var defaultLength = vars.graphSize.defaultLength
    var centerCoords = [width/2, height/2]
    var cola = Cola
      .size([width, height])
      .avoidOverlaps(true)
      .linkDistance(function (l) { if (l.length) { return l.length } else { return defaultLength }})
      .convergenceThreshold(1e-4)
      // .handleDisconnected(true)

    var initialState = { model: this.props.model, centerCoords: centerCoords, cola: cola }

    if (areFiltersSet(filtersByType)) {
      debug('getInitialState', 'filters set')
      //compute graph
      var nodesAndLinks = formatGraphData(this.props.model, this.props.model.filtersByType, centerCoords)
      var nodes = nodesAndLinks[0]
      var links = nodesAndLinks[1]

      if (nodes.length > 0) {
        nodes.forEach(function (entity, i) { entity.index = i})
        initialState.cola.nodes(nodes).links(links)

        // // trigger force graph
        // cola.start(10, 15, 20)

        // cola.on('tick', function () {
        //   this.setState({ nodes: cola.nodes() })
        // }.bind(this))

        initialState.nodes = ensurePostioning(this.props.model, initialState.cola.nodes())
        initialState.link = initialState.cola.links()
      }
    }

    return initialState
  },

  componentWillReceiveProps: function (nextProps) {
    debug('componentWillReceiveProps', nextProps)

    if (nextProps.model
      && nextProps.model.getId() !== this.state.model.getId() //new model
      &&  areFiltersSet(nextProps.model.filtersByType)) { //default filters are present

      // compute new graph
      var nodesAndLinks = formatGraphData(nextProps.model, nextProps.model.filtersByType, [vars.graphSize.width/2, vars.graphSize.height/2])
      var nodes = nodesAndLinks[0]
      var links = nodesAndLinks[1]

      if (nodes.length > 0) {
        nodes.forEach(function (entity, i) { entity.index = i})
        var cola = this.state.cola || getCola(vars.graphSize.width, vars.graphSize.height, vars.graphSize.defaultLength)
        cola.nodes(nodes)
            .links(links)

        cola.start(10, 15, 20) //compute new positions
        var currentNodes = ensurePostioning(nextProps.model, cola.nodes())

        //compute graph animation sequence and reset node state on ease cycle
        this.animateGraph({
          oldNodes: this.state.nodes,
          currentNodes: currentNodes,
          currentLinks: cola.links()
        })

        // reset filters -> updates headers and context tags
        this.setState({ filtersByType: nextProps.model.filtersByType })

      }

      debug('nodesAndLinks', nodesAndLinks)
    }

  },

  render: function () {
    debug('props, state', this.props, this.state)
    var route = this.props.route
    var actions = {}

    var props = extend(
      this.props,
      {
        actions: actions,
        nodes: this.state.nodes,
        links: this.state.links,
        cola: this.state.cola,
        filtersByType: this.state.filtersByType,
        updateTag: this.updateTag.bind(this),
        Icon: Icon,
        style: style
      }
    )



    var Page
    if (route) {
      Page = types.indexedByCollection[route.collection].Page
    } else {
      Page = FourOhFourPage
    }

    debug('render', props, route)
    return (
      r(Layout, props,
        r(Page, props)
      )
    )
  },

  animateGraph: animateGraph.bind(this),

  componentDidMount: function () {
    this.props.model.on('change', function (model, val) {
      debug('model, changing', model, val, this.state)
      var filtersByType  = model.filtersByType

      if (areFiltersSet(filtersByType)) {
        //compute graph
        var nodesAndLinks = formatGraphData(model, filtersByType, this.state.centerCoords)
        var nodes = nodesAndLinks[0]
        var links = nodesAndLinks[1]

        if (nodes.length > 0) {
          nodes.forEach(function (entity, i) { entity.index = i})
          var cola = this.state.cola
          cola
            .nodes(nodes)
            .links(links)

          //trigger force graph
          // cola.start(10, 15, 20)

          // cola.on('tick', function () {
          //   this.setState({ nodes: cola.nodes() })
          // }.bind(this))

          var state = {
            filtersByType: filtersByType,
            cola: cola,
            nodes: ensurePostioning(model, cola.nodes()),
            links: cola.links()
          }

          this.setState(state)
        }

        // this.state.cola.start(10, 15, 20)
        this.forceUpdate()
      }

    }, this)
  },

  updateTag: function (type, id, bool) {
    var memo = type === 'triple' ? {} : []
    return function () {
      debug('updateTag', type, id, bool)
      var tagData = clone(this.state.tagData, true)
      var tagCollection = reduce(tagData[type], function (memo, tag, ki) {
        debug('ki', ki)
        if (tag.id === id) tag.active = bool
        memo[ki]= tag
        return memo
      }, memo)
      tagData[type] = tagCollection
      debug('tagData', tagData)
      this.setState({ tagData: tagData })
    }.bind(this)
  },

  handleUpdateFilters: function () {
    //compute new graph
    //set state -> nodesAndLinks, filters


  }



})
