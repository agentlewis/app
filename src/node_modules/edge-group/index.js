// main
import component from 'virtual-component'
const svg = require('virtual-dom/virtual-hyperscript/svg')
const vars = require('ui/vars')
const R = require('ramda')

//debug
var debug = require('debug')('edge-group')

const getCenter = bounds => {

  return { cx: (bounds.x + bounds.X) / 2, cy: (bounds.y + bounds.Y) / 2 }
}

const getHypotenuse = bounds => {
  const { X, x, Y, y } = bounds
  return Math.sqrt(Math.pow(X - x, 2) + Math.pow(Y - y, 2))
}

const renderEllipse = (group, padding) => {
  const { bounds } = group
  const { X, x, Y, y } = bounds
  const { cx, cy } = getCenter(bounds)
  debug('center', cx, cy, getCenter(bounds))
  return svg('ellipse', {
    cx: cx,
    cy: cy,
    rx: Math.max(X - x, Y - y),
    ry: padding,
    stroke: 'black',
    fill: 'none'
  })
}

const renderGroups = group => {
  if (group.leaves.length === 2) {
    return renderEllipse(group, 20)
  }
}


const render = props => {
  const { queries, nodes, groups, links } = props
  const edgeGroups = groups && groups[0] && groups[0].bounds ? R.map(renderGroups, groups) : null

  debug('queries', nodes, groups, links)



  return svg('g', { class: 'query-group' }, [
    edgeGroups
  ])

}


const EdgeGroup = {
  render
}

module.exports = (props, children) => component(EdgeGroup, props, children)

//
// module.exports = React.createClass({
//
//   propTypes: {
//     nodes: React.PropTypes.array,
//     edges: React.PropTypes.array,
//     queries: React.PropTypes.array,
//     model: React.PropTypes.object
//   },
//
//   getInitialState: function () {
//     return {
//       activeHalos: {}
//     }
//   },
//
//   render: function () {
//     debug(this.props)
//
//     return (
//       r.g({ className: 'query-group' },
//         this.props.queries.active.reduce(function (memo, query) {
//           var edges, halos
//           if (query.showHalo) {
//             halos = this.props.nodes.filter(function (node) {
//               return node.activeHalosById && node.activeHalosById[query.id]
//             })
//           }
//           if (query.showLink) {
//             edges = this.props.edges.filter(function (edge) {
//               return edge.query.id === query.id
//             })
//           }
//
//           if (halos || edges) {
//             debug('halos', halos)
//             memo.push(r.g({ key: query.id, className: 'query-layer' }, [
//               halos ? r.g({ className: 'halos' },
//                 halos.map(function (node) {
//                   return this.renderHalos(node, query.id)
//                 }.bind(this))) : null,
//               edges ? r.g({ className: 'edges' },
//                 edges.map(function (edge) {
//                   return r(Edge, { edge: edge })
//                 })) : null
//             ]))
//           }
//
//           debug('memo', memo)
//
//           return memo
//         }.bind(this), [])
//
//       )
//     )
//   },
//
//   renderHalos: function (node, queryId) {
//     var w = node.w
//     var x = node.x
//     var y = node.y
//     var i = node.activeHalos.length - node.activeHalos.indexOf(queryId)
//     return r.circle({
//       cx: x,
//       cy: y,
//       r: w / 2 + (i * vars.haloWidth) + 2,
//       fill: node.activeHalosById[queryId].component.color,
//       stroke: 'white',
//       strokeWidth: 1
//     })
//   }
// })
