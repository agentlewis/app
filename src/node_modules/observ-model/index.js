var extend = require('xtend')
var ObservComputed = require('observ/computed')
var ObservStruct = require('observ-struct')

module.exports = {
  createClass: createClass,
}

function createClass (opts) {

  //
  // default args
  //
  opts = opts || {}
  opts.idAttribute = opts.idAttribute || 'id'
  opts.typeAttribute = opts.typeAttribute || 'type'
  opts.type = opts[opts.typeAttribute] || "ObservModel"
  opts.props = opts.props || {}
  opts.observPrefix = opts.observPrefix || '$'

  return ObservModel

  function ObservModel (context) {
    
    // default args
    context = context || {}

    //
    // setup model attributes
    //
    var modelAttrs = prefixProps(opts.observPrefix, opts.props)

    // create model observable
    var observModel = ObservStruct(modelAttrs)

    // create computed observable with unprefixed props
    var unprefixedModel = ObservComputed([observModel], function (props) {
      return unprefixProps(opts.observPrefix, props)
    })

    // create dummy model to return
    var model = function (listener) {
      return unprefixedModel(listener)
    }

    // link attributes on observ model to dummy model
    Object.keys(modelAttrs).forEach(function (prefixedPropName) {
      model[prefixedPropName] = observModel[prefixedPropName]
    })

    //
    // setup methods
    //

    model.get = function (propName) {
      if (!propName) {
        return unprefixedModel()
      }
      var prop = observModel[prefixPropName(opts.observPrefix, propName)]
      if (prop) {
        return prop()
      }
      return null
    }

    model.getId = function () {
      return model.get(opts.idAttribute)
    }

    model.getType = function () {
      return model.get(opts.typeAttribute)
    }

    model.set = function (propName, newVal) {
      if (!newVal) {
        newVal = propName
        return observModel.set(prefixProps(opts.observPrefix, newVal))
      }
      var prop = observModel[prefixPropName(opts.observPrefix, propName)]
      if (prop) {
        return prop.set(newVal)
      }
      return false
    }

    // abstract function called when parent is destroyed
    model.destroy = function () {

    }

    model._type = opts.type

    return model
  }

  // abstract function to be overriden by children
  ObservModel.extend(function (context) {

  })
}

function prefixPropName (prefix, propName) {
  return prefix + propName
}

function unprefixPropName (prefix, propName) {
  return propName.substring(prefix.length)
}

function prefixProps (prefix, props) {
  var prefixedProps = {}
  Object.keys(props).forEach(function (propName) {
    var prefixedPropName = prefixPropName(prefix, propName)
    prefixedProps[prefixedPropName] = props[propName]
  })
  return prefixedProps 
}

function unprefixProps (prefix, props) {
  var unprefixedProps = {}
  Object.keys(props).forEach(function (propName) {
    var unprefixedPropName = unprefixPropName(prefix, propName)
    unprefixedProps[unprefixedPropName] = props[propName]
  })
  return unprefixedProps
}

/*
var MyClass = {
  new: function () {
    var object = Object.create(this)
    this.initialize.call(object, arguments)
    return object
  },
  initialize: function () {

  },
}

var OtherClass = extend(MyClass, {
  new: function () {
    var base = Object.create(this)
  },
}

var myInstance = MyClass.new()
*/

// TODO
function belongsTo () {}
function hasOne () {}
function hasMany () {}
function belongsToMany () {}
