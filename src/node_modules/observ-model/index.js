var extend = require('xtend')
var forEach = require('for-each')
var mapValues = require('map-values')
var mapKeys = require('object-keys-map')
var ObservComputed = require('observ/computed')
var ObservStruct = require('observ-struct')

module.exports = {
  createClass: createClass,
}

function createClass (opts) {

  //
  // default args
  //
  opts = opts || {}
  opts.idAttribute = opts.idAttribute || 'id'
  opts.type = opts.type || "ObservModel"
  opts.version = opts.version || "0.0.0"
  opts.props = opts.props || {}
  opts.derived = opts.derived || {}
  opts.observPrefix = opts.observPrefix || '$'

  return ObservModel

  function ObservModel (context) {
    
    // default args
    context = context || {}

    //
    // setup model props
    //
    var setProps = opts.props
    var derivedProps = computedProps(opts.props, opts.derived)
    var modelProps = extend(setProps, derivedProps)

    // create model observable
    var observModel = ObservStruct(
      prefixProps(
        opts.observPrefix,
        setProps
      )
    )
    
    forEach(derivedProps, function (propDef, propName) {
      observModel[propName] = propDef
    })

    // create computed observable with unprefixed props
    var unprefixedModel = ObservComputed([observModel], function (props) {
      return unprefixProps(opts.observPrefix, props)
    })

    //
    // create dummy model to return
    //
    var model = function (listener) {
      return unprefixedModel(listener)
    }

    // link methods on observ model to dummy model
    forEach(observModel, function (attr, attrName) {
      if (typeof attr === 'function') {
        model[attrName] = attr
      }
    })

    model._type = opts.type
    model._version = opts.version


    //
    // setup methods
    //

    model.get = function (propName) {
      if (!propName) {
        return extend(
          unprefixedModel(),
          mapValues(derivedProps, function (obs) {
            return obs()
          })
        )
      }
      var prop = modelProps[propName]
      if (prop) {
        return prop()
      }
      return undefined
    }

    model.getId = function () {
      return model.get(opts.idAttribute)
    }

    model.getType = function () {
      return model._type
    }

    model.getVersion = function () {
      return model._version
    }

    model.set = function (propName, newVal) {
      if (!newVal) {
        newVal = propName
        return observModel.set(
          prefixProps(opts.observPrefix, newVal)
        )
      }
      var prop = setProps[propName]
      if (prop) {
        return prop.set(newVal)
      }
      return false
    }

    // abstract function called when parent is destroyed
    model.destroy = function () {

    }

    return model
  }

  // abstract function to extend class with context
  ObservModel.extend(function (context) {

  })
}

function prefixPropName (prefix, propName) {
  return prefix + propName
}

function unprefixPropName (prefix, propName) {
  return propName.substring(prefix.length)
}

function prefixProps (prefix, props) {
  return mapKeys(props, function (propName) {
    return prefixPropName(prefix, propName)
  })
}

function unprefixProps (prefix, props) {
  return mapKeys(props, function (propName) {
    return unprefixPropName(prefix, propName)
  })
}

function computedProps (modelProps, derivedDefs) {

  var derivedProps = {}
  
  forEach(derivedDefs, function (derivedDef, derivedName) {
    var deps = derivedDef.splice(0, derivedDef.length - 1)
    var fn = derivedDef[derivedDef.length - 1]

    var observDeps = deps.map(function (dep) {
      return modelProps[dep]
    })

    derivedProps[derivedName] = ObservComputed(observDeps, fn)
  })

  return derivedProps
}

// TODO
function belongsTo () {}
function hasOne () {}
function hasMany () {}
function belongsToMany () {}
