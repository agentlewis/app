var extend = require('xtend')
var forEach = require('for-each')
var mapValues = require('map-values')
var ObservComputed = require('observ/computed')
var ObservStruct = require('observ-struct')

module.exports = {
  createClass: createClass,
}

function createClass (opts) {

  //
  // default args
  //
  opts = opts || {}
  opts.idAttribute = opts.idAttribute || 'id'
  opts.typeAttribute = opts.typeAttribute || 'type'
  opts.type = opts[opts.typeAttribute] || "ObservModel"
  opts.props = opts.props || {}
  opts.derived = opts.derived || {}
  opts.observPrefix = opts.observPrefix || '$'

  return ObservModel

  function ObservModel (context) {
    
    // default args
    context = context || {}

    //
    // setup model props
    //
    var setProps = opts.props
    var derivedProps = computedProps(opts.props, opts.derived)
    var modelProps = extend(setProps, derivedProps)

    // create model observable
    var observModel = ObservStruct(
      prefixProps(
        opts.observPrefix,
        setProps
      )
    )
    
    forEach(derivedProps, function (propName, derivedProp) {
      observModel[propName] = derivedProp
    })

    // create computed observable with unprefixed props
    var unprefixedModel = ObservComputed([observModel], function (props) {
      return unprefixProps(opts.observPrefix, props)
    })

    // create dummy model to return
    var model = function (listener) {
      return unprefixedModel(listener)
    }

    // link attributes on observ model to dummy model
    Object.keys(observModel).forEach(function (attr) {
      model[attr] = observModel[attr]
    })

    //
    // setup methods
    //

    model.get = function (propName) {
      if (!propName) {
        return extend(
          unprefixedModel(),
          mapValues(derivedProps, function (obs) {
            return obs()
          })
        )
      }
      var prop = modelProps[propName]
      if (prop) {
        return prop()
      }
      return null
    }

    model.getId = function () {
      return model.get(opts.idAttribute)
    }

    model.getType = function () {
      return model.get(opts.typeAttribute)
    }

    model.set = function (propName, newVal) {
      if (!newVal) {
        newVal = propName
        return observModel.set(
          prefixProps(opts.observPrefix, newVal)
        )
      }
      var prop = setProps[propName]
      if (prop) {
        return prop.set(newVal)
      }
      return false
    }

    // abstract function called when parent is destroyed
    model.destroy = function () {

    }

    model._type = opts.type

    return model
  }

  // abstract function to extend class with context
  ObservModel.extend(function (context) {

  })
}

function prefixPropName (prefix, propName) {
  return prefix + propName
}

function unprefixPropName (prefix, propName) {
  return propName.substring(prefix.length)
}

function prefixProps (prefix, props) {
  var prefixedProps = {}
  Object.keys(props).forEach(function (propName) {
    var prefixedPropName = prefixPropName(prefix, propName)
    prefixedProps[prefixedPropName] = props[propName]
  })
  return prefixedProps 
}

function unprefixProps (prefix, props) {
  var unprefixedProps = {}
  Object.keys(props).forEach(function (propName) {
    var unprefixedPropName = unprefixPropName(prefix, propName)
    unprefixedProps[unprefixedPropName] = props[propName]
  })
  return unprefixedProps
}

function computedProps (modelProps, derivedDefs) {

  var derivedProps = {}
  
  Object.keys(derivedDefs).forEach(function (derivedName) {
    var derivedDef = derivedDefs[derivedName]
    
    var deps = derivedDef.splice(0, derivedDef.length - 1)
    var fn = derivedDef[derivedDef.length - 1]

    var observDeps = deps.map(function (dep) {
      return modelProps[dep]
    })

    derivedProps[derivedName] = ObservComputed(observDeps, fn)
  })

  return derivedProps
}

// TODO
function belongsTo () {}
function hasOne () {}
function hasMany () {}
function belongsToMany () {}
