var Model = require('base/model');
var _ = require('lodash');
var debug = require('debug')("craftodex:ui:relationship:model");

var registry = require('registry');

function Relationship (attrs, options) {
  debug("constructor", attrs, options);
  return Model.apply(this, arguments);
}

Model.extend({
  constructor: Relationship,
  modelType: "Relationship",

  props: {
    relationshipType: "state",
    is: "state",
    has: "state",
    symmetric: "state",
  },

  set: function (key, value, options) {
    debug("set", this, key, value, options);

    // Replicating a bit of the source so we can support all set 
    var attrs;
    options = options || {};

    // Handle both `"key", value` and `{key: value}` -style arguments.
    if (_.isObject(key) || key === null) {
        attrs = key;
        options = value;
    } else {
        attrs = {};
        attrs[key] = value;
    }

    var RelationshipType = require('relationship-type/model');

    if (!this.relationshipType && attrs.relationshipType && !attrs.relationshipType.isState) {
      attrs.relationshipType = new RelationshipType(attrs.relationshipType);
    }

    //
    // polymorphic types for 'is' and 'has' children props
    //
    var Group = require('group/model');
    var Person = require('person/model');

    if (!this.is && attrs.is && !attrs.is.isState) {
      switch (attrs.is['@type']) {
        case 'Group': attrs.is = new Group(attrs.is); break;
        case 'Person': attrs.is = new Person(attrs.is); break;
      }
    }
    if (!this.has && attrs.has && !attrs.has.isState) {
      switch (attrs.has['@type']) {
        case 'Group': attrs.has = new Group(attrs.has); break;
        case 'Person': attrs.has = new Person(attrs.has); break;
      }
    }

    if (!this.symmetric && attrs.symmetric && !attrs.symmetric.isState) {
      attrs.symmetric = new Relationship(attrs.symmetric);
    }

    // defer rest to the original implementation
    return Model.prototype.set.call(this, attrs, options);
  },

});

module.exports = Relationship;
