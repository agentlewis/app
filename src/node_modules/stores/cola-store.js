var Reflux = require('reflux')
var Actions = require('actions')
var Cola = require('graph-view/webcola-adaptor')()
var vars = require('ui/vars')
var routeStore = require('./route-store')
var debug = require('debug')('stores:cola-store')
var matrixZoom = require('matrix-zoom')

function ensurePostioning (model, nodes, centerCoords) {
  if (model['@type'] === 'Group' && model.parentGroups.length > 0) {
    return nodes.reduce(function (memo, node) {
      if (model.parentGroups[0].getId() === node.id) { // assumes 1 parent
        node.y = 0
      } else if (model.getId() === node.id) {
        node.x = centerCoords[0]
        node.y = centerCoords[1]
      }
      memo.push(node)
      return memo
    }, [])
  } else { return nodes }
}

function getCola (width, height) {
  return Cola
    .size([width, height])
    .avoidOverlaps(true)
    .linkDistance(function (l) {
      if (l.length) {
        return l.length
      } else { return vars.graphSize.defaultLength }
    })
    .convergenceThreshold(1e-4)
}

var colaStore = Reflux.createStore({

  listenables: Actions,

  init: function () {
    this.modelId = null
    this.colaBusy = false
    this.zoomInit = null
    this.count = 0
    this.countMax = 300
    this.nodesAndLinks = []
    this.nodes = []
    this.links = []
    this.width = vars.graphSize.width
    this.height = vars.graphSize.height
    this.dragOrigin = null
    this.vectorOrigin = null
    this.vector = [0, 0, 1]
    this.centerCoords = [vars.graphSize.width / 2, vars.graphSize.height / 2]
    this.queries = { active: [], inactive: [], queryMap: {}}

    this.listenTo(routeStore, this.onRouteStoreUpdate)
  },

  onRouteStoreUpdate: function (payload) {
    debug('onRouteStoreUpdate', payload)
    if (payload.height) { this.height = payload.height }
    if (payload.width) { this.width = payload.width }
    if (payload.centerCoords) { this.centerCoords = payload.centerCoords }

    // if (payload.scale) { this.scale = payload.scale }
    if (payload.width || payload.height) {
      this.trigger({ width: this.width, height: this.height })
    }

    debug('onRouteStoreUpdate', payload)
    if (payload.model && !payload.route && !payload.staticUpdate) {
      this.addNodesAndLinks({
        modelId: payload.model.getId(),
        model: payload.model,
        nodes: payload.nodes,
        links: payload.links,
        queries: payload.queries,
        vector: payload.vector
      })
    } else if (!payload.route && payload.staticUpdate) {
      debug('holdPositions', payload)
      this.updateNodeHalos(payload)
      this.queries = payload.queries
      this.updateView()
    }
    else if (!payload.route && payload.vector) {

      debug('vector', this.vector)
      this.updateView()
    }
  },

  updateNodeHalos: function (payload) {
    this.nodes = this.nodes.map(function (node, i) {
      var updateNode = payload.nodes[i]
      if (node.id === updateNode.id) {
        node.activeHalos = updateNode.activeHalos
        node.activeHalosById = updateNode.activeHalosById
      }
      return node
    })
  },

  // handles logic for updating graph
  addNodesAndLinks: function (payload) {
    debug('onAddNodesAndLinks', payload)
    this.queries = payload.queries
    if (!this.model && payload.nodes.length) {
      this.model = payload.model
      this.computePositions(payload, this.startAnimation)
      // this.updateView()
    } else if (this.model && this.model.id !== payload.model.id) {
      debug('new model', payload, this.vector)
      this.model = payload.model
      payload.vector = [0, 0, 1]
      this.computePositions(payload, this.startAnimation)
    } else if (payload.nodes.length) {
      debug('same model queries changed', payload)

      this.computePositions(payload, this.startAnimation)
    }
  },

  setGraph: function (graph) {
    debug('setGraph', graph)
    this.nodes = graph.nodes || this.nodes
    this.links = graph.links || this.links
    this.queries = graph.queries
  },

  updateView: function () {
    // debug('updateView')
    this.trigger({
      nodes: this.nodes,
      links: this.links,
      queries: this.queries,
      vector: this.vector
    })
  },

  //TODO animateGraph accepts old and new vector and scale
  startAnimation: function (payload) {
    debug('startAnimation', payload.vector, this.vector)
    this.animateGraph({
      oldVector: this.vector, //existing vector -> [0, 0]
      currentVector: payload.vector || this.vector,
      oldNodes: this.nodes,
      oldLinks: this.links,
      currentLinks: payload.links,
      currentNodes: ensurePostioning(this.model, payload.nodes, this.centerCoords)
    }, this.animationTick, this.animationEnd)
  },

  computePositions: function (payload, callback) {
    debug('computing positions', payload, this.vector)
    this.colaBusy = true
    this.cola = getCola(this.width, this.height)
    this.cola.nodes(payload.nodes).links(payload.links)
    this.cola.start(10, 15, 20)
    this.cola.stop()
    this.colaBusy = false
    callback({
      nodes: ensurePostioning(payload.model, this.cola.nodes(), this.centerCoords),
      links: this.cola.links(),
      queries: payload.queries,
      vector: payload.vector
    })
    this.copy = this.cola
  },

  tickUpdate: function () {
    this.cola.start()
    this.cola.on('tick', function () {
      if (this.count < this.countMax) {
        this.nodes = this.cola.nodes()
        this.links = this.cola.links()
        this.updateView()
        this.count ++
      } else {
        this.endTickUpdate()
      }
    }.bind(this))

    this.cola.on('end', function () {
      this.endTickUpdate()
    }.bind(this))
  },

  endTickUpdate: function () {
    debug('endTickUpdate')
    this.cola.stop()
    this.count = 0
    this.cola.on('tick', null)
  },

  animateGraph: require('animate/animate-graph'),

  animationTick: function (graph) {
    this.links = graph.links || this.links
    this.nodes = graph.nodes || this.nodes
    this.queries = graph.queries || this.queries
    this.vector = graph.vector || this.vector
    debug('vector', this.vector)
    this.updateView()
  },

  animationEnd: function (graph) {
    debug('animationEnd', graph)
    this.links = graph.links ? graph.links : this.links
    this.nodes = graph.nodes ? graph.nodes : this.nodes
    this.vector = graph.vector || this.vector
    this.updateView()
    this.tickUpdate()
  },

  onWheel: function (payload) {
    var dScale = payload.delta ? Math.pow(1.2, payload.delta/360) : 1

    this.vector = matrixZoom(
      this.vector,
      [payload.point[0], payload.point[1], dScale ]
    )

    this.zoomInit = Date.now()
    setTimeout(function () {
      if (Date.now() >= (this.zoomInit + 500) ) {
        Actions.zoomEnd({ vector: this.vector })
      }
    }.bind(this), 500)

    this.trigger({ vector: this.vector })
    debug('onWheel', payload, this.vector)


  },

  onDragStart: function (payload) {
    debug('onDragStart')
    this.dragOrigin = payload.origin
    this.vectorOrigin = this.vector
  },

  onDrag: function (payload) {
    var dx = payload.point[0] - this.dragOrigin[0]
    var dy = payload.point[1] - this.dragOrigin[1]

    this.vector = [
      this.vectorOrigin[0] + dx,
      this.vectorOrigin[1] + dy,
      this.vector[2]
    ]

    debug('onDrag', this.vector, payload, this.dragOrigin)
    this.trigger({ vector: this.vector })
  },

  onDragEnd: function (payload) {
    debug('onDragEnd', payload.vector)
    this.dragOrigin = null
    this.vectorOrigin = null
    // this.vector = payload.vector
  },

  getNodes: function () {
    return this.nodes
  },

  getLinks: function () {
    return this.links
  },

  getQueries: function () {
    return this.queries
  },

  getWidth: function () {
    return this.width
  },

  getHeight: function () {
    return this.height
  },

  getVector: function () {
    return this.vector
  },
})

module.exports = colaStore
