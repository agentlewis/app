var Reflux = require('reflux')
var Actions = require('actions')
var Cola = require('graph-view/webcola-adaptor')()
var vars = require('ui/vars')
var filtersStore = require('./filters-store')
var formatGraphData = require('graph-view/format-graph-data')
var map = require('lodash.map')


var debug  = require('debug')('stores:cola-store')


function ensurePostioning (model, nodes) {
  if (model['@type'] === 'Group' && model.parentGroups.length > 0) {
    return nodes.reduce(function (memo, node) {
      if (model.parentGroups[0].getId() === node.id) { node.y = 0 } //assumes 1 parent
      else if (model.getId() === node.id) {
        node.x = vars.graphSize.width/2
        node.y = vars.graphSize.height/2
      }
      memo.push(node)
      return memo
    }, [])
  }
  else {
    return nodes
  }
}

function getCola (width, height) {
  return Cola
      .size([width, height])
      .avoidOverlaps(true)
      .linkDistance(function (l) {
        if (l.length) { return l.length }
        else { return vars.graphSize.defaultLength }
      })
      .convergenceThreshold(1e-4)
}

var colaStore = Reflux.createStore({

  listenables: Actions,

  init: function () {
    this.modelId = null
    this.colaBusy = false
    this.count = 0
    this.countMax = 200
    this.nodesAndLinks = []
    this.nodes = []
    this.links = []
    this.width = vars.graphSize.width
    this.height = vars.graphSize.height
    this.centerCoords = [this.width/2, this.height/2]
    // this.cola = getCola(this.width, this.height)

    this.listenTo(filtersStore, this.onFiltersStoreUpdate)
  },

  onQuerystringUpdate: function (query) {

  },

  onFiltersStoreUpdate: function (payload) {
    debug('filtersStore Update', payload)
    if (payload.holdPositions) {
      this.formatGraph(payload)
      this.setGraph({ links: this.nodesAndLinks[1] }) //only set links
      this.connectNodesWithLinks()
      this.updateView()
    }
    else {
      this.formatGraph(payload)
      this.addNodesAndLinks({
        modelId: payload.model.getId(),
        model: payload.model,
        nodesAndLinks: this.nodesAndLinks,
      })
    }
  },

  connectNodesWithLinks: function () {
    this.links = map(this.links, function (link) {
      if (typeof link.source === 'number') {
        link.source = this.nodes[link.source]
        link.target = this.nodes[link.target]
      }
      return link
    }.bind(this))
  },

  formatGraph: function (payload) {
    this.nodesAndLinks = formatGraphData(payload.model, payload.filtersByType, this.centerCoords)
    debug('graph formatted', this.nodesAndLinks)
  },

  //handles logic for updating graph
  addNodesAndLinks: function (payload) {
    debug('onAddNodesAndLinks', payload)
    if (!this.modelId && payload.nodesAndLinks[0].length) {
      this.modelId = payload.modelId
      this.model = payload.model
      this.computePositions(payload, this.setGraph)
      this.updateView()
    }
    else if (this.modelId !== payload.modelId) {
      debug('new model')
      this.modelId = payload.modelId
      this.model = payload.model
      this.computePositions(payload, this.startAnimation)
    }
    else if (payload.nodesAndLinks[0].length) {
      debug('same model filters changed')
      this.computePositions(payload, this.startAnimation)
    }
  },

  setGraph: function (graph) {
    debug('setGraph', graph)
    this.nodes = graph.nodes || this.nodes,
    this.links = graph.links
  },

  updateView: function () {
    debug('updateView')
    this.trigger({
      nodes: this.nodes,
      links: this.links,
    })
  },

  startAnimation: function (payload) {
    debug('startAnimation', payload)
    this.animateGraph({
      oldNodes: this.nodes,
      oldLinks: this.links,
      currentLinks: payload.links,
      currentNodes: ensurePostioning(this.model, payload.nodes)
    }, this.animationTick, this.animationEnd)
  },


  computePositions: function (payload, callback) {
    debug('computing positions', payload)
    this.colaBusy = true
    this.cola = getCola(this.width, this.height)
    this.cola.nodes(payload.nodesAndLinks[0]).links(payload.nodesAndLinks[1])
    this.cola.start(10, 15, 20)
    this.cola.stop()
    // var nodes = ensurePostioning(payload.model, this.cola.nodes())
    // var links = this.cola.links()
    this.colaBusy = false
    callback({
      nodes: ensurePostioning(payload.model, this.cola.nodes()),
      links: this.cola.links()
    })
    this.copy = this.cola
    // this.cola = null
    // this.tickUpdate()
  },

  tickUpdate: function () {
    this.cola.start()
    this.cola.on('tick', function () {
      if (this.count < this.countMax) {
        this.nodes = this.cola.nodes()
        this.links = this.cola.links()
        // this.cola.tick()
        this.updateView()
        this.count ++
        debug(this.count)
      }
      else {
        this.endTickUpdate()
      }
    }.bind(this))

    this.cola.on('end', function () {
      this.endTickUpdate()
    }.bind(this))
  },

  endTickUpdate: function () {
    debug('endTickUpdate')
    this.cola.stop()
    this.count = 0
    this.cola.on('tick', null)
  },

  animateGraph: require('animate/animate-graph'),

  animationTick: function (graph) {
    debug('animationTick')
    this.links = graph.links ? graph.links : this.links
    this.nodes = graph.nodes ? graph.nodes : this.nodes
    this.updateView()
  },

  animationEnd: function (graph) {
    debug('animationEnd', graph)
    this.links = graph.links ? graph.links : this.links
    this.nodes = graph.nodes ? graph.nodes : this.nodes
    this.updateView()
    this.tickUpdate()

  },

  getNodes: function () {
    return this.nodes
  },

  getLinks: function () {
    return this.links
  },


})

module.exports = colaStore
