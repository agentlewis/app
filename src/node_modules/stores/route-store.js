var Reflux = require('reflux')
var Actions = require('actions')
var vars = require('ui/vars')
var m = require('minimal-immutable')
var each = require('lodash.foreach')
var clone = require('lodash.clone')
var keys = require('lodash.keys')
var isEqual = require('lodash.isequal')
var Url = require('url')
var find = require('lodash.find')
var parseQuerytoMap = require('graph-view/parse-query-to-map')
var getDefaultQueryMap = require('graph-view/get-default-query-map')
var getQueries = require('graph-view/get-queries')

var config = require('config')
var prefix = Url.format(config.api)

//DEFAULTS

var member = prefix + '/roleTypes/member'
var subgroup = prefix + '/roleTypes/subgroup'
var subgroupLink = subgroup + '/link'


var debug  = require('debug')('stores:route-store')

function hasSameKeys (obj0, obj1) {
  var keys0 = keys(obj0)
  var keys1 = keys(obj1)
  if (keys0.length !== keys1.length) { return false }
  return keys0.every(function (key0) {
    if (!obj1[key0]) { return false }
    return true
  })
}

function graphIsEqual (nextQueryMap, queryMap) {
  if (!hasSameKeys(nextQueryMap, queryMap)) { return false }
  else {
    return keys(nextQueryMap).every(function (key) {
      return hasSameKeys(nextQueryMap[key], queryMap[key])
    })
  }
}

var routeStore = Reflux.createStore({

  listenables: Actions,

  init: function () {
    this.modelId = null
    this.search = null
    this.queryMap = null
  },

  onModelUpdate: function (payload) {
    var queryMap
    if (payload.route.search === '') {
      queryMap = getDefaultQueryMap(payload.model)
    }
    else {
      queryMap = parseQuerytoMap(payload.route.query)
    }

    this.queries = getQueries(payload.model, queryMap)
    this.trigger({ model: payload.model, queries: this.queries })
  },

  onRouteChange: function (payload) {
    debug('onRouteChange', payload)

    if (payload.route.id !== this.modelId) {
      debug('new Model')
      //new model -> redraw
      //TODO transition queryMap (common links)
      var queryMap
      if (payload.route.search === '') {
        queryMap = getDefaultQueryMap(payload.model)
      }
      else {
        queryMap = parseQuerytoMap(payload.route.query)
      }


      this.queries = getQueries(payload.model, queryMap)
      debug('queries', this.queries)
      this.modelId = payload.route.id
      this.search = payload.route.search
      this.trigger({ model: payload.model, queries: this.queries })
    }
    else {

      var queryMap = parseQuerytoMap(payload.route.query)
      if(!graphIsEqual(queryMap, this.queryMap)) {
        debug('same model different layout -> redraw')
        //same model different layout -> redraw
      }
      else if (this.search !== payload.route.search) {
        debug('same model, same layout, different visuals')
        //same model, same layout, different visuals

      }

    }




  },

  updateQuery: function (route) {
    this.query = route.query
  },




  onCancelTag: function (payload) {
    // debug('onCancelTag', payload)
    // var type = payload.filter.contextAgentId ? 'context' : 'targetAgent'
    // if (payload.type === 'AgentType') {
    //   this.removeAgentTypeTag(payload)
    // }
    // else if (payload.type === 'Link') {
    //   var filtersByType = m.toJS(this.filtersByType)
    //   debug(filtersByType[type])
    //   var filter = find(filtersByType[type], function (filter) {
    //     return filter.id === payload.filter.id
    //   })
    //   if (filter.agentType.active) {
    //     debug('filtersStore', payload, filter)
    //     this.removeRoleOrLink(payload, 'linkType')
    //     this.updateListeners({ holdPositions: true })
    //   }
    //   else {
    //     debug('filtersStore', payload, filter)
    //
    //     this.removeRoleOrLink(payload, 'linkType')
    //     this.updateListeners()
    //   }
    // }
    // else if (payload.type === 'Role') {
    //   this.removeRoleOrLink(payload, 'roleType')
    //   this.updateListeners()
    // }
  },

  onAddTag: function (payload) {
    // debug('onAddTag', payload)
    // var filtersByType = m.toJS(this.filtersByType)
    // var type = payload.filter.contextAgentId ? 'context' : 'targetAgent'
    // var filters = filtersByType[type]
    //
    // var updatedFilters = filters.reduce(function (memo, filter) {
    //   if (filter.id === payload.filter.id) {
    //     if (payload.type === 'Role') {
    //       filter.roleType.active = true
    //     }
    //     else if (payload.type === 'Link') {
    //       filter.linkType.active = true
    //     }
    //     else if (payload.type === 'AgentType') {
    //       filter.agentType.active = true
    //     }
    //   }
    //   memo.push(filter)
    //   return memo
    // }, [])
    //
    // filtersByType[type] = updatedFilters
    // this.filtersByType = m.fromJS(filtersByType)
    // this.updateListeners()
  },

  removeAgentTypeTag: function (payload) {
    // debug('removeAgentTypeTag', payload)
    // var filtersByType = m.toJS(this.filtersByType)
    // var updatedFilters = filtersByType.targetAgent.map(function (filter) {
    //   if (filter.agentType.id === payload.filter.agentType.id) {
    //     var updatedFilter = clone(filter)
    //     debug('updated filter')
    //     updatedFilter.agentType.active = false
    //     return updatedFilter
    //   }
    //   else { return filter}
    // })
    // filtersByType.targetAgent = updatedFilters
    // this.filtersByType = m.fromJS(filtersByType)
    // this.updateListeners()
  },

  removeRoleOrLink: function (payload, prop) {
    // debug('removeRoleOrLink', payload, prop)
    // var filtersByType = m.toJS(this.filtersByType)
    // var type = payload.filter.contextAgentId ? 'context' : 'targetAgent'
    // var updatedFilters = filtersByType[type].map(function (filter) {
    //   if (filter.id === payload.filter.id) {
    //     var updatedFilter = clone(filter)
    //     updatedFilter[prop].active = false
    //     return updatedFilter
    //   }
    //   else { return filter }
    // })
    // filtersByType[type] = updatedFilters
    // debug('updatedFilters', updatedFilters)
    // this.filtersByType = m.fromJS(filtersByType)
  },

  // getFiltersByType: function () {
  //   return m.toJS(this.filtersByType)
  // },

  updateListeners: function (options) {
    debug('updateListeners')
    // this.trigger({
    //   model: this.model,
    //   filtersByType: m.toJS(this.filtersByType),
    //   holdPositions: (options && options.holdPositions)
    // })
  },



})

module.exports = routeStore
