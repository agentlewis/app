var Reflux = require('reflux')
var Actions = require('actions')
var vars = require('ui/vars')
var m = require('minimal-immutable')
var each = require('lodash.foreach')
var clone = require('lodash.clone')
var Url = require('url')
var find = require('lodash.find')

var config = require('config')
var prefix = Url.format(config.api)
var Labels = require('graph-view/labels')

//DEFAULTS

var member = prefix + '/roleTypes/member'
var subgroup = prefix + '/roleTypes/subgroup'
var subgroupLink = subgroup + '/link'


  var debug  = require('debug')('stores:filters-store')

var filtersStore = Reflux.createStore({

  listenables: Actions,

  init: function () {
    this.modelId = null,
    this.filtersByType = m.fromJS({ targetAgent: [], context:[] })
  },

  //handles logic for updating graph
  onUpdateFilters: function (model) {
    debug('onUpdateFilters', model)
    var candidate = m.fromJS(model.filtersByType)
    if (!m.equals(this.filtersByType, candidate)) { //filtersByType has changed
      if (!this.modelId || this.modelId !== model.getId) {
        this.modelId = model.getId()
        this.model = model
        this.filtersByType = m.fromJS(model.filtersByType)
        this.updateListeners()
      }
    }

  },

  onCancelTag: function (payload) {
    debug('onCancelTag', payload)
    var type = payload.filter.contextAgentId ? 'context' : 'targetAgent'
    if (payload.type === 'AgentType') {
      this.removeAgentTypeTag(payload)
    }
    else if (payload.type === 'Link') {
      var filtersByType = m.toJS(this.filtersByType)
      debug(filtersByType[type])
      var filter = find(filtersByType[type], function (filter) {
        return filter.id === payload.filter.id
      })
      if (filter.agentType.active) {
        debug('filtersStore', payload, filter)
        this.removeRoleOrLink(payload, 'linkType')
        this.updateListeners({ holdPositions: true })
      }
      else {
        debug('filtersStore', payload, filter)

        this.removeRoleOrLink(payload, 'linkType')
        this.updateListeners()
      }
    }
    else if (payload.type === 'Role') {
      this.removeRoleOrLink(payload, 'roleType')
      this.updateListeners()
    }
  },

  onAddTag: function (payload) {
    debug('onAddTag', payload)
    var filtersByType = m.toJS(this.filtersByType)
    var type = payload.filter.contextAgentId ? 'context' : 'targetAgent'
    var filters = filtersByType[type]

    var updatedFilters = filters.reduce(function (memo, filter) {
      if (filter.id === payload.filter.id) {
        if (payload.type === 'Role') {
          filter.roleType.active = true
        }
        else if (payload.type === 'Link') {
          filter.linkType.active = true
        }
        else if (payload.type === 'AgentType') {
          filter.agentType.active = true
        }
      }
      memo.push(filter)
      return memo
    }, [])

    filtersByType[type] = updatedFilters
    this.filtersByType = m.fromJS(filtersByType)
    this.updateListeners()
  },

  removeAgentTypeTag: function (payload) {
    debug('removeAgentTypeTag', payload)
    var filtersByType = m.toJS(this.filtersByType)
    var updatedFilters = filtersByType.targetAgent.map(function (filter) {
      if (filter.agentType.id === payload.filter.agentType.id) {
        var updatedFilter = clone(filter)
        debug('updated filter')
        updatedFilter.agentType.active = false
        return updatedFilter
      }
      else { return filter}
    })
    filtersByType.targetAgent = updatedFilters
    this.filtersByType = m.fromJS(filtersByType)
    this.updateListeners()
  },

  removeRoleOrLink: function (payload, prop) {
    debug('removeRoleOrLink', payload)
    var filtersByType = m.toJS(this.filtersByType)
    var type = payload.filter.contextAgentId ? 'context' : 'targetAgent'
    var updatedFilters = filtersByType[type].map(function (filter) {
      if (filter.id === payload.filter.id) {
        var updatedFilter = clone(filter)
        updatedFilter[prop].active = false
        return updatedFilter
      }
      else { return filter }
    })
    filtersByType[type] = updatedFilters
    this.filtersByType = m.fromJS(filtersByType)

  },

  getFiltersByType: function () {
    return m.toJS(this.filtersByType)
  },

  updateListeners: function (options) {
    debug('updateListeners')
    this.trigger({
      model: this.model,
      filtersByType: m.toJS(this.filtersByType),
      holdPositions: (options && options.holdPositions)
    })
  },



})

module.exports = filtersStore
