var map = require('observ-node-array/map')
var debug = require('debug')("holodex:agent:model")

var BaseModel = require('base/model')

function AgentModel (context, mixin) {

  var agentModel = BaseModel(extend({
    $name: Observ(),
    $image: Observ(),
  }, mixin))

  agentModel._type = "Agent"

  agentModel.$roles = map(context.atom.$roles, function (role) {
    if (role.$agent.$id() === agentModel.$id()) {
      return role
    }
  })

  agentModel.$relationships = map(agentModel.$roles, function (role) {
    return role.relationship
  })

  return agentModel
}

AgentModel.extend = function (context) {
  // ensure atom has filtered set of agents
  if (!context.atom.agents) {
    context.atom.$agents = map(context.atom, function (entity) {
      if (
        entity.$type() === "Person" ||
        entity.$type() === "Group"
      ) {
        return entity
      }
    })
  }
}

/*
module.exports = Model.extend({

  modelType: "Agent",

  initialize: function () {
    debug("initialize", this)
    Model.prototype.initialize.apply(this, arguments)
    this.on("change", debug.bind(null, "change"))
  },

  props: {
    name: "string",
    image: "url",
  },

  collections: {
    relationships: relationships,
    roles: Roles,
  },

  derived: {
    relsByType: {
      deps: ['relationships'],
      cache: false,
      fn: function () {
        debug("relationships", this.relationships)

        var rels = {}
        this.relationships.forEach(function (rel) {
          var relType = rel.type
          if (!relType) return
          var relType = relType.getId()
          if (!rels[relType]) {
            rels[relType] = new Relationships()
          }
          rels[relType].add(rel)
        })

        debug("relsByType ->", rels)
        return rels
      },
    },

    relatedTypes: {
      deps: ['relsByType'],
      cache: false,
      fn: function () {
        var relatedTypes = Object.keys(this.relsByType)
        debug("relatedTypes ->", relatedTypes)
        return relatedTypes
      },
    },

    relatedNodes: {
      deps: ['relsByType'],
      cache: false,
      fn: function () {
        var relatedNodes = _.union(_.flatten(
          this.relationships.map(function (rel) {
            return [rel.is].concat([rel.has])
          })
        ))
        debug("relatedNodes ->", relatedNodes)
        return relatedNodes
      },
    },

    relatedEdges: {
      deps: ['relsByType'],
      cache: false,
      fn: function () {
        var relatedEdges = {}
        
        _.forEach(this.relatedTypes, function (relType) {
          relatedEdges[relType] = {}
        })

        this.relationships.forEach(function (rel) {
          var relType = rel.type
          if (!relType) return
          relType = relType.getId()

          var relEdges = relatedEdges[relType]
          
          var relIs = rel.is.getId()
          var relHas = rel.has.getId()

          if (!_.isArray(relEdges[relIs])) {
            relEdges[relIs] = []
          }
          relEdges[relIs].push(relHas)
        })

        debug("relatedEdges ->", relatedEdges)
        return relatedEdges
      },
    },

    // TODO inward and outward relationships
    hasRelsByType: {
      deps: ['relsByType'],
      cache: false,
      fn: function () {
        debug("relsByType", this.relsByType)

        var hasRels = {}
        
        _.forEach(this.relsByType, function (rels, isType) {

          var hasType = isType.symmetric

          hasRels[hasType] = new Relationships()

          rels.forEach(function (rel) {
            
            if (
              rel.is &&
              (rel.is.getId() === this.getId())
            ) {
              var is = rel.is
              var has = is.symmetric
              hasRels[hasType].add(has)
            }

          }, this)
        }, this)

        debug("hasRelsByType ->", hasRels)
        return hasRels
      },
    },
  },

})
*/

