var Model = require('base/model');
var debug = require('debug')("craftodex:agent:model");
var _ = require('lodash');

var Relationships = require('relationship/collection');

module.exports = Model.extend({

  modelType: "Agent",

  initialize: function () {
    debug("initialize", this);
    Model.prototype.initialize.apply(this, arguments);
    this.relationships.reset(); // children hack
    this.on("change", debug.bind(null, "change"));
  },

  props: {
    name: "string",
    image: "url"
  },

  children: {
    relationships: Relationships,
  },

  derived: {
    relsByType: {
      deps: ['relationships'],
      cache: false,
      fn: function () {
        debug("relationships", this.relationships);

        var rels = {};
        this.relationships.forEach(function (rel) {
          var relType = rel.relationshipType;
          if (!relType) return;
          var relType = relType.getId();
          if (!rels[relType]) {
            rels[relType] = new Relationships();
          }
          rels[relType].add(rel);
        });

        debug("relsByType ->", rels);
        return rels;
      },
    },

    relatedTypes: {
      deps: ['relsByType'],
      cache: false,
      fn: function () {
        var relatedTypes = Object.keys(this.relsByType);
        debug("relatedTypes ->", relatedTypes);
        return relatedTypes;
      },
    },

    relatedNodes: {
      deps: ['relsByType'],
      cache: false,
      fn: function () {
        var relatedNodes = _.union(_.flatten(
          this.relationships.map(function (rel) {
            return [rel.is].concat([rel.has]);
          })
        ));
        debug("relatedNodes ->", relatedNodes);
        return relatedNodes;
      },
    },

    relatedEdges: {
      deps: ['relsByType'],
      cache: false,
      fn: function () {
        var relatedEdges = {};
        
        _.forEach(this.relatedTypes, function (relType) {
          relatedEdges[relType] = {};
        });

        this.relationships.forEach(function (rel) {
          var relType = rel.relationshipType;
          if (!relType) return;
          relType = relType.getId();

          var relEdges = relatedEdges[relType]
          
          var relIs = rel.is.getId();
          var relHas = rel.has.getId();

          if (!_.isArray(relEdges[relIs])) {
            relEdges[relIs] = [];
          }
          relEdges[relIs].push(relHas);
        });

        debug("relatedEdges ->", relatedEdges);
        return relatedEdges;
      },
    },

    // TODO inward and outward relationships
    hasRelsByType: {
      deps: ['relsByType'],
      cache: false,
      fn: function () {
        debug("relsByType", this.relsByType)

        var hasRels = {};
        
        _.forEach(this.relsByType, function (rels, isType) {

          var hasType = isType.symmetric;

          hasRels[hasType] = new Relationships();

          rels.forEach(function (rel) {
            
            if (
              rel.is &&
              (rel.is.getId() === this.getId())
            ) {
              var is = rel.is;
              var has = is.symmetric;
              hasRels[hasType].add(has);
            }

          }, this)
        }, this);

        debug("hasRelsByType ->", hasRels)
        return hasRels;
      },
    },
  },

});
