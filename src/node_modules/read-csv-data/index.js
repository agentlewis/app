var Path = require('path')
var mapValues = require('lodash.mapvalues')
var csv = require('csv-parser')

var types = require('types')
var typesByCollection = types.indexedByCollection

module.exports = readData

function readData (opts, cb) {
  var graph = []
  var tasks = mapValues(typesByCollection, function (type, collectionName) {
    return getCollection({
      dir: opts.dir,
      type: type,
      collectionName: collectionName,
      graph: graph
    })
  })
  runAuto(tasks, function (err) {
    if (err) { return cb(err) }
    cb(null, graph)
  })
}

function getCollection (opts) {
  var task = [function (cb, results) {
    readCollection({
      dir: opts.dir,
      collectionName: opts.collectionName
    })
    .pipe(trimify())
    .pipe(typify(opts.collectionName, opts.graph))
    .on('end', function () {
      debug('got', opts.collectionName)
      cb()
    })
    .on('error', cb)
    .resume()
  }]
  if (opts.collectionName === 'relationships') {
    task.unshift('people', 'groups', 'roleTypes', 'relationshipTypes', 'linkTypes')
  }
  return task
}

function readCollection (opts) {
  var fileName = Path.join(opts.dir, opts.collectionName + '.csv')
  var stream
  try {
    stream = fs.createReadStream(fileName)
  } catch (err) {
    // return empty readable stream
    return from.obj(function (size, next) {
      next(null, null)
    })
  }
  return stream.pipe(csv())
}

function trimify () {
  return through.obj(function (data, enc, cb) {
    cb(null, mapValues(data, function (val) {
      return val.trim()
    }))
  })
}

function typify (collectionName, graph) {
  var type = types.indexedByCollection[collectionName]
  var Model = type.Model

  // hard-coded parsers for types of data
  // TODO fix HACK
  var parsers = {
    Role: function parseRole (attrs) {
      return {
        id: 'roles/' + uuid(),
        type: 'roleTypes/' + attrs.role,
        agent: 'people/' + attrs.agent
      }
    },
    RoleType: function parseRoleType (attrs) {
      return assign(attrs, {
        relationshipType: 'relationshipTypes/' + attrs.relationshipType
      })
    },
    LinkType: function parseLinkType (attrs) {
      return assign(attrs, {
        relationshipType: 'relationshipTypes/' + attrs.relationshipType,
        source: 'roleTypes/' + attrs.source,
        target: 'roleTypes/' + attrs.target
      })
    },
    Relationship: function parseRelationship (attrs) {
      var apiUrl = Url.format(config.api)
      var linkType = store.findById(apiUrl + '/linkTypes/' + attrs.link)

      var relId = 'relationships/' + uuid()

      var sourceRole = Model.new({
        '@id': uuid(),
        '@type': 'Role',
        type: linkType.source.getId(),
        agent: findAgent(attrs.source).getId(),
        relationship: relId
      })
      var targetRole = Model.new({
        '@id': uuid(),
        '@type': 'Role',
        type: linkType.target.getId(),
        agent: findAgent(attrs.target).getId(),
        relationship: relId
      })

      graph.push(sourceRole, targetRole)

      return {
        id: uuid(),
        type: linkType.relationshipType.getId(),
      }
    }
  }

  return through.obj(function (row, enc, cb) {

    var type = Model.prototype.getType()
    var attrs = row.value

    if (parsers[type]) {
      attrs = parsers[type](attrs)
    }

    // rename idAttribute to '@id'
    attrs['@id'] = collectionName + '/' + attrs.id
    delete attrs.id

    // add '@type' attribute
    attrs['@type'] = type

    var model = Model.new(attrs)

    model.save()
    
    graph.push(model)
    
    cb(null, model)
  })
}

function print () {
  return through.obj(function (model, enc, cb) {
    console.log(model.toJSON())
    cb()
  })
}

function findAgent (id) {
  var apiUrl = Url.format(config.api)
  return store.findById(apiUrl + '/people/' + id) ||
    store.findById(apiUrl + '/groups/' + id)
}
