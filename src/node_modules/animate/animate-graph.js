
var raf = require('raf')
var interpolate = require('util/interpolate')
var ease = require('eases/cubic-in-out')
var vars = require('ui/vars')
var debug = require('debug')('animate:animate-graph')
var deepClone = require('clone')

module.exports =   function (options, ctx) {


    debug('animateNodes', options, ctx.state.nodes)
    var model = options.model
    var oldNodes = options.oldNodes
    var currentNodes = options.currentNodes
    var currentLinks = options.currentLinks

    var self = ctx
    var start = null
    var oldIdToIndex = {}
    var enterNodes = []
    var transitionNodes = []
    var exitNodes = [] //Do something with exiting nodes?
    var nodeInterpolators = [] //2-dimensional array of [node[x,y], ...] interpolate functions
    var transitionLinks = []
    var enterLinks = []

    function interpolateNode (oldNode, currentNode) {
      var xInterpolate = interpolate(oldNode.x, currentNode.x)
      var yInterpolate = interpolate(oldNode.y, currentNode.y)
      var sizeInterpolate = (oldNode.w !== currentNode.w) ? interpolate(oldNode.w, currentNode.w) : null
      return [xInterpolate, yInterpolate, sizeInterpolate]
    }

    for (var i=0, len = oldNodes.length; i < len; i++) {
      oldIdToIndex[oldNodes[i].id] = i
    }

    //sort nodes into those entering and transitioning
    for (var i=0, len = currentNodes.length; i < len; i++) {
      var currentNode = currentNodes[i]
      if (typeof oldIdToIndex[currentNode.id] === 'number') {
        transitionNodes.push(currentNode)
      }
      else { enterNodes.push(currentNode) }
    }

    for (var i=0, len = currentLinks.length; i < len; i++) {
      var currentLink = currentLinks[i]
      if (typeof oldIdToIndex[currentLink.source.id] === 'number'
      && typeof oldIdToIndex[currentLink.target.id] === 'number') {
        transitionLinks.push(currentLink)
      }
    }

    debug('transitionNodes', transitionNodes)
    for (var i=0, len = transitionNodes.length; i < len; i++) {
      var node = transitionNodes[i]
      var oldNode = oldNodes[oldIdToIndex[node.id]]
      debug('oldNode', oldNode)
      debug('node', node)
      nodeInterpolators.push(
        interpolateNode(oldNode, node)
      )
    }

    function tick (timeStamp) {
      var t0,t1,value
      if (start === null) start = timeStamp
      t0 = (timeStamp - start)/vars.transition.duration
      t1 = ease(t0);
      var nodes = []

      for (var i=0, len = transitionNodes.length; i < len; i++) {
        var interpolator = nodeInterpolators[i]
        var node = transitionNodes[i]
        node.y = interpolator[1](t1)
        node.x = interpolator[0](t1)
        if (interpolator[2]) {
          node.w = interpolator[2](t1)
          node.h = interpolator[2](t1)
        }

        nodes.push(node)
      }

      self.setState({ nodes: nodes })
      if (t0 < 1) {
        debug('tick', nodes)
        raf(tick)
      }
      else {
        debug('finished transition', transitionNodes)
        var cola = self.state.cola
          // cola.on('tick', function () {
          //   self.setState({ nodes: cola.nodes() })
          // })
        // cola.start(10, 15, 20)
        var transitionAndEnterNodes = self.state.nodes.concat(enterNodes)
        self.setState({
          nodes: transitionAndEnterNodes,
          cola: cola,
          model: model,
          links: currentLinks,
          filtersByType: model.filtersByType
        }) // transition ended ->
        self.state.cola.start(10, 15, 20)
    }
    }

    var cola = self.state.cola
    //halt cola ticking
    cola.on('tick', null)
    cola.stop()
    self.setState({ links: transitionLinks, cola: cola }) //remove old links that do not transistion
    raf(tick)
  }
