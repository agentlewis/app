var extend = require('xtend')
var forEach = require('for-each')
var reduce = require('reduce')
var mapValues = require('map-values')
var mapKeys = require('object-keys-map')
var ObservComputed = require('observ/computed')
var ObservStruct = require('observ-struct')

module.exports = createType

function createType (defn) {

  //
  // default definition options
  //
  defn = defn || {}
  defn.type = defn.type || "ObservType"
  defn.version = defn.version || "0.0.0"
  defn.observPrefix = defn.observPrefix || '$'
  defn.props = defn.props || {}
  defn.derived = defn.derived || {}
  defn.extend = defn.extend || []

  // extend options
  defn = extendDefn(defn, defn.extend)

  // store definition for type extensions
  ObservType.definition = Object.freeze(defn)

  return ObservType

  function ObservType (context) {
    
    // default args
    context = context || {}

    //
    // setup type props
    //
    var setProps = defn.props
    var derivedProps = computedProps(defn.props, defn.derived)
    var typeProps = extend(setProps, derivedProps)

    // create type observable
    var observType = ObservStruct(
      prefixProps(
        defn.observPrefix,
        setProps
      )
    )
    
    forEach(derivedProps, function (propDef, propName) {
      observType[propName] = propDef
    })

    // create computed observable with unprefixed props
    var unprefixedType = ObservComputed([observType], function (props) {
      return unprefixProps(defn.observPrefix, props)
    })

    //
    // create dummy type to return
    //
    var type = function (listener) {
      return unprefixedType(listener)
    }

    // link methods on observ type to dummy type
    forEach(observType, function (attr, attrName) {
      if (typeof attr === 'function') {
        type[attrName] = attr
      }
    })

    type._type = defn.type
    type._version = defn.version

    //
    // setup methods
    //

    type.get = function (propName) {
      if (!propName) {
        return extend(
          unprefixedType(),
          mapValues(derivedProps, function (obs) {
            return obs()
          })
        )
      }
      return typeProps[propName]
    }

    type.getId = function () {
      return type.get(defn.idAttribute)
    }

    type.getType = function () {
      return type._type
    }

    type.getVersion = function () {
      return type._version
    }

    type.set = function (propName, newVal) {
      if (!newVal) {
        newVal = propName
        return observType.set(
          prefixProps(defn.observPrefix, newVal)
        )
      }
      var prop = setProps[propName]
      if (prop) {
        prop.set(newVal)
        return true
      }
      return false
    }

    // abstract function called when parent is destroyed
    type.destroy = function () {

    }

    return type
  }

  // abstract function to extend class with context
  ObservType.extend(function (context) {

  })
}

function prefixPropName (prefix, propName) {
  return prefix + propName
}

function unprefixPropName (prefix, propName) {
  return propName.substring(prefix.length)
}

function prefixProps (prefix, props) {
  return mapKeys(props, function (propName) {
    return prefixPropName(prefix, propName)
  })
}

function unprefixProps (prefix, props) {
  return mapKeys(props, function (propName) {
    return unprefixPropName(prefix, propName)
  })
}

function computedProps (typeProps, derivedDefs) {

  var derivedProps = {}
  
  forEach(derivedDefs, function (derivedDef, derivedName) {
    var deps = derivedDef.splice(0, derivedDef.length - 1)
    var fn = derivedDef[derivedDef.length - 1]

    var observDeps = deps.map(function (dep) {
      return typeProps[dep]
    })

    derivedProps[derivedName] = ObservComputed(observDeps, fn)
  })

  return derivedProps
}

function extendDefn (defn, extensionTypes) {

  if (!Array.isArray(extensionTypes)) {
    extensionTypes = [extensionTypes]
  }

  var extensionDefns = extensionTypes.map(function (type) {
    return type.definition
  })

  return reduce(extensionDefns, function (acc, item, index) {
    return extend(acc, item, mapValues(acc, function (val, key) {
      if (key === 'type') {
        if (Array.isArray(item[key])) {
          return item[key].concat([val])
        }
        return [item[key]].concat([val])
      }
      if (typeof val === 'object') {
        return extend(val, item[key])
      }
      return val
    }))
  }, defn)
}

// TODO
function belongsTo () {}
function hasOne () {}
function hasMany () {}
function belongsToMany () {}
