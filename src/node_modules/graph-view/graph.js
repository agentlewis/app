'strict'
// takes node and edge data and out node and edge svgs
// import { interpolateZoom } from 'd3-jsnext'

var React = require('react')
var r = require('r-dom')
var Reflux = require('reflux')

var colaStore = require('stores/cola-store')

var h = require('create-element')
var debug = require('debug')('holodex:graph-view:graph')
var Transform = require('d3-transform')
var d3InterpolateZoom = require('animate/d3-interpolate-zoom')

var router = require('router')
var Node = require('./node-ui')
var EdgeGroup = require('./edge-group')
var vars = require('ui/vars')

var transform = Transform()
  .translate(function (d) { return [d.x, d.y]})
  .scale(function (d) { return d.scale  })

function location(p, view) {
  return [(p[0] - view.x) / view.k, (p[1] - view.y) / view.k];
}

function point(l, options) {
  return [l[0] * options.k + options.x, l[1] * options.k + options.y];
}

function scaleTo(s, scaleExtent) {
  return Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
}

function translateTo(p, l, view) {
  l = point(l, view);
  view.x += p[0] - l[0];
  view.y += p[1] - l[1];
}

// if (!d3_behavior_zoomWheel) {
//   d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() { return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1); }, "wheel")
//       : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() { return d3.event.wheelDelta; }, "mousewheel")
//       : (d3_behavior_zoomDelta = function() { return -d3.event.detail; }, "MozMousePixelScroll");
// }

module.exports = React.createClass({
  mixins: [
    Reflux.listenTo(colaStore, 'onColaUpdate')
  ],

  propTypes: {
    model: React.PropTypes.object,
    route: React.PropTypes.object,
    Icon: React.PropTypes.object
  },

  getInitialState: function (options) {
    return {
      nodes: colaStore.getNodes(),
      links: colaStore.getLinks(),
      queries: { active: [], inactive: [], queryMap: {} },
      width: colaStore.getWidth(),
      height: colaStore.getHeight(),
      dragging: false,
      dragStart: false,
      client: [null, null],
      offset: [0, 0],
      scale: 1,
      center: [colaStore.getWidth() / 2, colaStore.getHeight() / 2]
    }
  },

  onColaUpdate: function (graph) {
    // debug('graph:', graph)
    if (graph.nodes) {
      this.setState({
        nodes: graph.nodes,
        links: graph.links,
        queries: graph.queries
      })
    } else if (graph.width) {
      this.setState({
        width: graph.width,
        height: graph.height
      })
    }
  },

  render: function () {
    // debug('props', this.props, this.state)
    var nodes = this.state.nodes
    var edges = this.state.links
    var transformString = transform({
        x: this.state.offset[0],
        y: this.state.offset[1],
        scale: this.state.scale
    })
    debug('transformString', transformString)
    debug('state', this.state)

    return (
      r.svg(
        {
          // draggable: true, //NOTE React does not support native drag events on svgs
          className: 'graph-svg',
          width: this.state.width,
          height: this.state.height,
          style: { cursor: this.state.dragging ? 'move' : 'auto' },
          onMouseDown: this.handleMouseDown,
          onMouseMove: this.handleMouseMove,
          onMouseUp: this.handleMouseUp,
          onWheel: this.handleWheel
          // onDragStart: this.handleDragStart,
        },
        [
          r.g(
            {
              id: 'transform-layer',
              transform: 'matrix(' + this.state.scale + ',0,0,' + this.state.scale + ',' + this.state.offset[0] + ',' + this.state.offset[1] + ')'
            },
            [
              r.g({className: 'halo-group'}, [
                r(EdgeGroup,
                    {
                      queries: this.state.queries,
                      nodes: nodes,
                      edges: edges,
                      model: this.props.model,
                      route: this.props.route
                    }
                  )
                ]
              ),
              r.g({className: 'node-group'}, [
                nodes.map(function (node) {
                  // debug('node', node)
                  return r(Node,
                    {
                      node: node,
                      key: node.id,
                      Icon: this.props.Icon,
                      handleClick: this.handleAgentClick(node.data)
                    }
                  )
                }.bind(this))
              ]
            )
          ]
        )]
      )
    )
  },

  componentWillReceiveProps: function (nextProps) {
    debug('componentWillReceiveProps', {nextProps: nextProps}, this.state)
  },

  getHref: function (model) {
    return router.format({ id: model.id })
  },

  navigate: router.navigate.bind(router),

  handleAgentClick: function (model) {
    var self = this
    return function () {
      // self.props.setColaTick(false)
      debug('handleClick', model)
      self.navigate(self.getHref(model))
    }
  },

  handleMouseDown: function (e) {
    debug('mousedown', e.target.className.baseVal)
    if (e.target.className.baseVal === 'graph-svg') {
      this.setState({
        dragging: true,
        // dragStart: true,
        client: { x: e.clientX, y: e.clientY }
      })
    }
  },

  handleMouseMove: function (e) {
    if (this.state.dragging) {
      var dx = (e.clientX - this.state.client.x)
      var dy = (e.clientY - this.state.client.y)

      this.setState({
        offset: [
          this.state.offset[0] + dx,
          this.state.offset[1] + dy
        ],
        client: { x: e.clientX, y: e.clientY },
      })
    }
  },

  handleMouseUp: function (e) {
    debug('mouseup', e)
    this.setState({
      dragging: false,
      client: { x: null, y: null },
    })
  },

  handleWheel: function (e) {

    // var center
    // var center0
    // var translate0 = {}
    var DOMNode = React.findDOMNode(this)
    var layer = DOMNode.getElementById('transform-layer')
    var point = DOMNode.createSVGPoint()

    point.x = e.clientX
    point.y = e.clientY

    var svgGlobal = point.matrixTransform(layer.getCTM().inverse())
    // // if (svgGlobal.x === this.state.client[0] && svgGlobal.y === this.state.client[1]) {
    //   center = this.state.center
    // // } else {
    // //   center = [this.state.width / 2, this.state.height / 2]
    // // }
    // var isSamePoint = (svgGlobal.x === this.state.client[0] && svgGlobal.y === this.state.client[1])
    //
    var newScale = scaleTo(Math.pow(2, e.deltaY * .002) * this.state.scale, [0.5, 2])
    var z = Math.pow(1.2, e.deltaY/360)
    // var scaleDelta = newScale - this.state.scale
    //
    // var dx = (center[0] * scaleDelta) + ((svgGlobal.x - center[0]) * scaleDelta)
    // var dy = (center[1] * scaleDelta) + ((svgGlobal.y - center[1]) * scaleDelta)


    var k = DOMNode.createSVGMatrix().translate(svgGlobal.x, svgGlobal.y).scale(z).translate(-svgGlobal.x, -svgGlobal.y)
    // if (svgGlobal.x !== this.state.client[0] && svgGlobal.y !== this.state.client[1]) {
    //
    // }

    var g = layer.getCTM().multiply(k)
    var h = layer.getCTM()
    // h.a = h.d = this.state.scale
    h.e = this.state.offset[0]
    h.f = this.state.offset[1]
    debug('h0', h.a, h.e, h.f)
    var j = h.multiply(k)
    // debug('i', DOMNode.getCTM())
    // debug('i', DOMNode.getCTM().scale(newScale))
    debug('state', this.state.scale, this.state.offset[0], this.state.offset[1])
    debug('g', g.a, g.e, g.f)
    debug('j', j.a, j.e, j.f)

    // debug((center[0] * scaleDelta), (center[1] * scaleDelta))
    // debug(((svgGlobal.x - center[0]) * scaleDelta), ((svgGlobal.y - center[1]) * scaleDelta))
    // debug(dx, dy)
    // debug(this.state.offset[0], this.state.offset[1])

    // translate0.x = (svgGlobal.x * scaleDelta) + ((center[0] - svgGlobal.x) * scaleDelta) - ((center[0] - svgGlobal.x) * scaleDelta)
    // translate0.y = (svgGlobal.y * scaleDelta) + ((center[1] - svgGlobal.y) * scaleDelta) - ((center[1] - svgGlobal.y) * scaleDelta)

    // translate0.x = (newScale * svgGlobal.x) - svgGlobal.x
    // translate0.y = (newScale * svgGlobal.y) - svgGlobal.y



    this.setState({
      scale: g.a,
      offset: [
        g.e,
        g.f
      ],
      client: [svgGlobal.x, svgGlobal.y]
    })


    // var view = {
    //   x: 0,
    //   y: 0,
    //   k: this.state.scale
    // }
    // var center0 = [this.state.width / 2, this.state.height / 2]
    // var translate0 = location([e.clientX, e.clientY], view)

    // debug('view', view)
    // translateTo(center0, translate0, view)
    // debug('view1', view)
    // this.setState({
    //   scale: view.k,
    //   offset: { x: view.x, y: view.y }
    // })

    var size = [this.state.width, this.state.height]
    // var scaleIndex = this.state.scaleRange.indexOf(this.state.scale)
    //
    // if (e.deltaY > 0) {
    //   if (scaleIndex !== this.state.scaleRange.length - 1) {
    //     scaleIndex += 1
    //   }
    // } else if (scaleIndex !== 0) {
    //   scaleIndex -= 1
    // }
    //
    // var dx = size[0],
    //     dy = size[1],
    //     cx = center0 ? center0[0] : dx / 2,
    //     cy = center0 ? center0[1] : dy / 2
    //

    // var view1 = { x: }
    //
    //
    // var i = d3InterpolateZoom(
    //   [(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k],
    //   [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]
    // )

    function tick (t) {
      var l = i(t), k = dx / l[2]
      return { x: cx - l[0] * k, y: cy - l[1] * k, k: k }
    }
    // debugger

    // var nextScale = this.state.scaleRange[scaleIndex]
    // var ratio = nextScale / this.state.scale
    //
    // var centerCoords = [center0[0] * ratio, center0[1] * ratio]

    //
    // var translateX = (nextX - e.clientX) / ratio
    // var translateY = (nextY - e.clientY) / ratio
    // debug('nextscale'. nextScale, ratio)
    // // debug('new', nextX, nextY)
    // debug('translate', translateX, translateY)

    // this.setState({
    //   scale: nextScale,
    //   offset: {
    //     x: this.state.offset.x - translateX,
    //     y: this.state.offset.y - translateY
    //   }
    // })

    // if (e.deltaY > 0) {
    //   this.setState({
    //     scale: (scaleIndex === this.state.scaleRange.length-1) ?
    //       this.state.scaleRange[scaleIndex] :
    //       this.state.scaleRange[scaleIndex + 1]
    //   })
    // } else {
    //   this.setState({
    //     scale: (scaleIndex === 0) ?
    //       this.state.scaleRange[0] :
    //       this.state.scaleRange[scaleIndex - 1]
    //   })
    // }

  }

})
