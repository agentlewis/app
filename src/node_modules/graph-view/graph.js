// takes node and edge data and out node and edge svgs
var React = require('react')
var r = require('r-dom')
var h = require('create-element')
var debug = require('debug')('holodex:graph-view:graph')

var Cola = require('./webcola-adaptor')()
var Node = require('./node-ui')
var Edge = require('./edge-ui')
var getTagData = require('./get-tag-data')
var formatGraphData = require('./format-graph-data')

var raf = require('raf')
var interpolate = require('util/interpolate')
var ease = require('eases/cubic-in-out')
var vars = require('ui/vars')

module.exports = React.createClass({
  propTypes: {
    model: React.PropTypes.object,
    actions: React.PropTypes.object,
    tagData: React.PropTypes.object
  },

  getInitialState: function (options) {
    debug('getInitialState')
    //TODO these as props
    var width = 700
    var height = 700
    var defaultLength = 90
    var centerCoords = [width/2, height/2]
    var self = this

    var cola = Cola
      .size([width, height])
      .avoidOverlaps(true)
      .linkDistance(function (l) { if (l.length) { return l.length } else { return defaultLength }})
      .convergenceThreshold(1e-4)
      .handleDisconnected(true)

    cola.on('tick', function () {
      var count = self.state.count+1
      if (count < self.state.maxTick) {
        self.setState({ nodes: cola.nodes(), count: count })
      }
      else {
        self.setState({ count: 0 })
      }
    })

    // trigger force graph
    cola.start(10, 15, 20)

    return {
      links: null,
      nodes: null,
      width: width,
      height: height,
      count: null,
      maxTick: 1000,
      cola: cola,
      centerCoords: centerCoords,
      contextAgentIndex: null
    }
  },

  render: function () {
    var nodes = this.state.nodes || []
    debug('render', this.state.count )
    var edges = this.state.links || this.state.cola.links()

    return (
      r.div({ id: 'graph' }, [
        r.svg({
          className: 'graph-svg',
            width: this.state.width,
            height: this.state.height
        }, [
          r.defs(),
          r.g({className: 'edge-group'}, [
            edges.map(function (edge) {
              return r(Edge,
                {
                  edge: edge,
                  key: edge.id
                }
              )
            })]
          ),
          r.g({className: 'node-group'}, [
            nodes.map(function (node) {
              return r(Node,
                {
                  node: node,
                  key: node.id,
                  Icon: this.props.Icon,
                  handleClick: this.handleClick(node.model)
                }
              )
            }.bind(this))
          ])
        ])
      ])
    )
  },

  componentDidMount: function () {
    debug('componentDidMount')
    var defs = this.getDOMNode().getElementsByTagName('defs')[0]
    var marker = h('marker',
      {
        id: 'arrowhead',
        viewBox:"0 0 10 10",
        refX:"1", refY:"5",
        markerWidth:"6",
        markerHeight:"6",
        orient:"auto"
      },
      h('path', { d: 'M 0 0 L 10 5 L 0 10 z', fill: 'grey' })
    )

    var circleClip20 = h('clipPath', { id: 'circle-clip-20' },
      h('circle', { cx: '20', cy: '20', r: '20' })
    )

    // insert our arrowhead marker and clip-path 'cos React doesn't support it? :(
    defs.insertAdjacentHTML('beforeend', marker)
    defs.insertAdjacentHTML('beforeend', circleClip20)
  },

  componentWillReceiveProps: function (nextProps) {
    debug('componentWillReceiveProps', {nextProps: nextProps})
    var model = nextProps.model
    var tagData = nextProps.tagData
    var graph = model.relationshipGraph

    // compute links
    var nodesAndLinks = formatGraphData(model, tagData, this.state.centerCoords)
    var nodes = nodesAndLinks[0]
    var links = nodesAndLinks[1]

    if (nodes.length > 0) {
      nodes.forEach(function (entity, i) { entity.index = i})
      var cola = this.state.cola
        .nodes(nodes)
        .links(links)
        .handleDisconnected(true)

        cola.on('tick', function () {
          var count = self.state.count+1
          if (count < self.state.maxTick) {
            self.setState({ nodes: cola.nodes(), count: count })
          }
          else {
            self.setState({ count: 0 })
          }
        })



      this.setState({ cola: cola, nodes: cola.nodes() })
      this.state.cola.start(10, 15, 20)
    }
  },

  animateNodes: function (oldNodes, currentNodes, currentLinks) {
    debug('animateNodes', oldNodes, currentNodes, currentLinks)
    var self = this
    var start = null
    var oldIdToIndex = {}
    var enterNodes = []
    var transitionNodes = []
    var exitNodes = [] //Do something with exiting nodes?
    var nodeInterpolators = [] //2-dimensional array of [node[x,y], ...] interpolate functions
    var transitionLinks = []
    var enterLinks = []

    function interpolateNode (oldNode, currentNode) {
      var xInterpolate = interpolate(oldNode.x, currentNode.x)
      var yInterpolate = interpolate(oldNode.y, currentNode.y)
      var sizeInterpolate = (oldNode.w !== currentNode.w) ? interpolate(oldNode.w, currentNode.w) : null
      return [xInterpolate, yInterpolate, sizeInterpolate]
    }

    for (var i=0, len = oldNodes.length; i < len; i++) {
      oldIdToIndex[oldNodes[i].id] = i
    }

    //sort nodes into those entering and transitioning
    for (var i=0, len = currentNodes.length; i < len; i++) {
      var currentNode = currentNodes[i]
      debug('currentNode', currentNode, oldIdToIndex)

      if (typeof oldIdToIndex[currentNode.id] === 'number') {
        transitionNodes.push(currentNode)
      }
      else { enterNodes.push(currentNode) }
    }

    for (var i=0, len = currentLinks.length; i < len; i++) {
      var currentLink = currentLinks[i]
      if (typeof oldIdToIndex[currentLink.source.id] === 'number'
      && typeof oldIdToIndex[currentLink.target.id] === 'number') {
        transitionLinks.push(currentLink)
      }
    }

    debug('transitionNodes', transitionNodes)
    for (var i=0, len = transitionNodes.length; i < len; i++) {
      var node = transitionNodes[i]
      var oldNode = oldNodes[oldIdToIndex[node.id]]
      nodeInterpolators.push(
        interpolateNode(oldNode, node)
      )
    }

    function tick (timeStamp) {
      var t0,t1,value
      if (start === null) start = timeStamp
      t0 = (timeStamp - start)/800 //duration
      t1 = ease(t0);
      var nodes = []
      // debug('transitionNodes', transitionNodes)
      for (var i=0, len = transitionNodes.length; i < len; i++) {
        var interpolator = nodeInterpolators[i]
        var node = transitionNodes[i]
        node.x = interpolator[0](t1)
        node.y = interpolator[1](t1)
        if (interpolator[2]) {
          var size = interpolator[2](t1)
          node.w = size
          node.h = size
        }

        nodes.push(node)
      }

      self.setState({ nodes: nodes })
      if (t0 < 1) {
        raf(tick)
      }
      else {
        var cola = self.state.cola
        //commence cola ticking
        cola.on('tick', function () {
          var count = self.state.count+1
          if (count < self.state.maxTick) {
            self.setState({ nodes: cola.nodes(), count: count })
          }
          else {
            self.setState({ count: 0 })
          }
        })
        var transitionAndEnterNodes = self.state.nodes.concat(enterNodes)
        self.setState({ nodes: transitionAndEnterNodes, links: null, cola: cola }) // transition ended -> add enter links from state.cola
      }
    }

    debug('transitionLinks', transitionLinks)
    var cola = self.state.cola
    //halt cola tiking
    cola.on('tick', null)
    self.setState({ links: transitionLinks, cola: cola }) //remove old links that do not transistion
    raf(tick)
  },

  transitionToParent: function (parentModel) {
    debug('transitionToParent', parentModel)
    var parentTagData = getTagData(parentModel)

    //set the currentContextGroup off to the lower left
    var options = {}
    options[this.props.model.getId()] = [
      this.state.centerCoords[0] - 120,
      this.state.centerCoords[1] + 200
    ]
    var parentNodesAndLinks = formatGraphData(parentModel, parentTagData, this.state.centerCoords, options)

    var currentContextNodes = this.state.nodes
    var cola = this.state.cola
    cola.nodes(parentNodesAndLinks[0])
      .links(parentNodesAndLinks[1])
    cola.start(10, 15, 20) //compute new positions

    this.animateNodes(this.state.nodes, cola.nodes(), cola.links()) //transition to new positions
  },

  handleClick: function (model) {
    var self = this
    return function () {
      debug('handleClick', model)
      // if (model['@type'] === 'Group' && self.props.model.parentGroups[0].getId() === model.getId()) {
        //NOTE assumes 1 parent
        // debug('is parent', self.transitionToParent)
        self.transitionToParent(model)
      // }
    }
  }
})
