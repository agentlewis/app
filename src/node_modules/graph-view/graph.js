'strict'
// takes node and edge data and out node and edge svgs
// import { interpolateZoom } from 'd3-jsnext'

var React = require('react')
var r = require('r-dom')
var Reflux = require('reflux')

var colaStore = require('stores/cola-store')
var Actions = require('actions')

var h = require('create-element')
var debug = require('debug')('holodex:graph-view:graph')
var Transform = require('d3-transform')
var d3InterpolateZoom = require('animate/d3-interpolate-zoom')
var add = require('vectors/add')(2)
var mult = require('vectors/mult')(2)
var m = require('matrix-utilities')

var reduce = require('lodash.reduce')

var router = require('router')
var Node = require('./node-ui')
var EdgeGroup = require('./edge-group')
var vars = require('ui/vars')

var transform = Transform()
  .translate(function (d) { return [d.x, d.y]})
  .scale(function (d) { return d.scale  })

function location(p, view) {
  return [(p[0] - view.x) / view.k, (p[1] - view.y) / view.k];
}

function point(l, options) {
  return [l[0] * options.k + options.x, l[1] * options.k + options.y];
}

function scaleTo(s, scaleExtent) {
  return Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
}

function translateTo(p, l, view) {
  l = point(l, view);
  view.x += p[0] - l[0];
  view.y += p[1] - l[1];
}

// if (!d3_behavior_zoomWheel) {
//   d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() { return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1); }, "wheel")
//       : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() { return d3.event.wheelDelta; }, "mousewheel")
//       : (d3_behavior_zoomDelta = function() { return -d3.event.detail; }, "MozMousePixelScroll");
// }

module.exports = React.createClass({
  mixins: [
    Reflux.listenTo(colaStore, 'onColaUpdate')
  ],

  propTypes: {
    model: React.PropTypes.object,
    route: React.PropTypes.object,
    Icon: React.PropTypes.object
  },

  getInitialState: function (options) {
    return {
      nodes: colaStore.getNodes(),
      links: colaStore.getLinks(),
      queries: { active: [], inactive: [], queryMap: {} },
      width: colaStore.getWidth(),
      height: colaStore.getHeight(),
      vector: colaStore.getVector(),
      scale: colaStore.getScale(),
      dragging: false,
      dragStart: false,
      client: { x: null, y: null },
      center: [colaStore.getWidth() / 2, colaStore.getHeight() / 2]
    }
  },

  onColaUpdate: function (payload) {
    debug('payload:', payload)
    this.setState(reduce(payload, function (memo, val, key) {
      memo[key] = val
      return memo
    }, {}))
  },

  render: function () {
    // debug('props', this.props, this.state)
    var nodes = this.state.nodes
    var edges = this.state.links
    var transformString = transform({
        x: this.state.vector[0],
        y: this.state.vector[1],
        scale: this.state.scale
    })
    debug('transformString', transformString)
    debug('state', this.state)

    return (
      r.svg(
        {
          // draggable: true, //NOTE React does not support native drag events on svgs
          className: 'graph-svg',
          width: this.state.width,
          height: this.state.height,
          style: { cursor: this.state.dragging ? 'move' : 'auto' },
          onMouseDown: this.handleMouseDown,
          onMouseMove: this.handleMouseMove,
          onMouseUp: this.handleMouseUp,
          onWheel: this.handleWheel
          // onDragStart: this.handleDragStart,
        },
        [
          r.g(
            {
              id: 'transform-layer',
              transform: transformString
            },
            [
              r.g({className: 'halo-group'}, [
                r(EdgeGroup,
                    {
                      queries: this.state.queries,
                      nodes: nodes,
                      edges: edges,
                      model: this.props.model,
                      route: this.props.route
                    }
                  )
                ]
              ),
              r.g({className: 'node-group'}, [
                nodes.map(function (node) {
                  // debug('node', node)
                  return r(Node,
                    {
                      node: node,
                      key: node.id,
                      Icon: this.props.Icon,
                      handleClick: this.handleAgentClick(node.data)
                    }
                  )
                }.bind(this))
              ]
            )
          ]
        )]
      )
    )
  },

  componentWillReceiveProps: function (nextProps) {
    debug('componentWillReceiveProps', {nextProps: nextProps}, this.state)
  },

  getHref: function (model) {
    return router.format({ id: model.id })
  },

  navigate: router.navigate.bind(router),

  handleAgentClick: function (model) {
    var self = this
    return function () {
      // self.props.setColaTick(false)
      debug('handleClick', model)
      self.navigate(self.getHref(model))
    }
  },

  handleMouseDown: function (e) {
    debug('mousedown', e.target.className.baseVal)
    if (e.target.className.baseVal === 'graph-svg') {
      this.setState({ dragging: true })
      Actions.dragStart({ origin: [e.clientX, e.clientY] })
    }
  },

  handleMouseMove: function (e) {
    if (this.state.dragging) {
      Actions.drag({ point: [e.clientX, e.clientY] })
    }
  },

  handleMouseUp: function (e) {
    debug('mouseup', e)
    if (this.state.dragging) {
      Actions.dragEnd({ vector: this.state.vector })
      this.setState({ dragging: false })
    }
  },

  handleWheel: function (e) {
    var DOMNode = React.findDOMNode(this)
    var point = DOMNode.createSVGPoint()
    var layer = DOMNode.getElementById('transform-layer')
    point.x = e.clientX
    point.y = e.clientY

    //convert mouse coordinates to svg coordinates
    var svgGlobal = point.matrixTransform(layer.getCTM().inverse())
    Actions.wheel({ point: [svgGlobal.x, svgGlobal.y], delta: e.deltaY })
  }
})
