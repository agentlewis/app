// takes node and edge data and out node and edge svgs
var React = require('react')
var r = require('r-dom')


var h = require('create-element')
var debug = require('debug')('holodex:graph-view:graph')

var router = require('router')
var Cola = require('./webcola-adaptor')()
var Node = require('./node-ui')
var Edge = require('./edge-ui')
var vars = require('ui/vars')

var getTagData = require('./get-tag-data')
var formatGraphData = require('./format-graph-data')

var contains = require('lodash.contains')
var raf = require('raf')
var interpolate = require('util/interpolate')
var ease = require('eases/cubic-in-out')


function ensurePostioning (model, nodes) {
  if (model['@type'] === 'Group' && model.parentGroups.length > 0) {
    return nodes.reduce(function (memo, node) {
      if (model.parentGroups[0].getId() === node.id) { node.y = 0 } //assumes 1 parent
      memo.push(node)
      return memo
    }, [])
  }
  else {
    return nodes
  }
}

module.exports = React.createClass({
  propTypes: {
    model: React.PropTypes.object,
    actions: React.PropTypes.object,
    tagData: React.PropTypes.object
  },

  getInitialState: function (options) {
    debug('getInitialState', this.props)
    //TODO these as props
    var width = vars.graphSize.width
    var height = vars.graphSize.height
    var defaultLength = 90
    var centerCoords = [width/2, height/2]
    var self = this

    var nodesAndLinks = formatGraphData(this.props.model, this.props.model.filtersByType, centerCoords)
    var nodes = this.props.nodes || nodesAndLinks[0] //old nodes from tansition
    var links = nodesAndLinks[1]

    var cola = Cola
      .size([width, height])
      .avoidOverlaps(true)
      .nodes(ensurePostioning(this.props.model, nodes))
      .links(links)
      .linkDistance(function (l) { if (l.length) { return l.length } else { return defaultLength }})
      .convergenceThreshold(1e-4)
      .handleDisconnected(true)

    // trigger force graph
    cola.start(10, 15, 20)

    return {
      links: cola.links(),
      nodes: cola.nodes(),
      width: width,
      height: height,
      cola: cola,
      centerCoords: centerCoords
    }
  },

  render: function () {
    var nodes = this.state.nodes || []
    var edges = this.state.links || this.state.cola.links()
    debug('nodes', nodes)
    return (
      r.div({ id: 'graph' }, [
        r.svg({
          className: 'graph-svg',
            width: this.state.width,
            height: this.state.height
        }, [
          r.defs(),
          r.g({className: 'edge-group'}, [
            edges.map(function (edge) {
              return r(Edge,
                {
                  edge: edge,
                  key: edge.id
                }
              )
            })]
          ),
          r.g({className: 'node-group'}, [
            nodes.map(function (node) {
              return r(Node,
                {
                  node: node,
                  key: node.id,
                  Icon: this.props.Icon,
                  handleClick: this.handleClick(node.model)
                }
              )
            }.bind(this))
          ])
        ])
      ])
    )
  },

  componentDidMount: function () {
    debug('componentDidMount', this.props)
    var defs = this.getDOMNode().getElementsByTagName('defs')[0]
    var marker = h('marker',
      {
        id: 'arrowhead',
        viewBox:"0 0 10 10",
        refX:"1", refY:"5",
        markerWidth:"6",
        markerHeight:"6",
        orient:"auto"
      },
      h('path', { d: 'M 0 0 L 10 5 L 0 10 z', fill: 'grey' })
    )

    var circleClip20 = h('clipPath', { id: 'circle-clip-20' },
      h('circle', { cx: '20', cy: '20', r: '20' })
    )

    // insert our arrowhead marker and clip-path 'cos React doesn't support it? :(
    defs.insertAdjacentHTML('beforeend', marker)
    defs.insertAdjacentHTML('beforeend', circleClip20)
  },

  componentWillReceiveProps: function (nextProps) {
    debug('componentWillReceiveProps', {nextProps: nextProps})
    var filtersByType = nextProps.filtersByType
    if (filtersByType) {

      // compute nodes an links
      var nodeMap = this.props.nodeMap || {}
      var nodesAndLinks = formatGraphData(nextProps.model, filtersByType, this.state.centerCoords)
      var nodes = nextProps.nodes || nodesAndLinks[0]
      var links = nodesAndLinks[1]

      if (nodes.length > 0) {
        nodes.forEach(function (entity, i) { entity.index = i})
        var cola = this.state.cola
          .nodes(nodes)
          .links(links)
          .handleDisconnected(true)

          cola.on('tick', function () {
            this.setState({ nodes: cola.nodes() })
          }.bind(this))

        this.setState({ cola: cola, nodes: cola.nodes() })
        this.state.cola.start(10, 15, 20)
      }
    }
  },


  // transitionToNode: function (model) {
  //   debug('transitionToNode', model)
  //   var cola = this.state.cola
  //   var self = this
  //   //set the currentContextGroup off to the lower left
  //   var options = {}
  //   options[this.props.model.getId()] = [
  //     this.state.centerCoords[0] - 120,
  //     this.state.centerCoords[1] + 200
  //   ]
  //   var nodesAndLinks = formatGraphData(model, model.filtersByType, this.state.centerCoords, options)
  //
  //   cola.nodes(nodesAndLinks[0])
  //     .links(nodesAndLinks[1])
  //   cola.start(10, 15, 20) //compute new positions
  //   var currentNodes = ensurePostioning(model, cola.nodes(), this.state.centerCoords)
  //
  //   var animateOptions = {
  //     oldNodes: this.state.nodes,
  //     currentNodes: currentNodes, //hack to acount for cola not always positioning fixed items
  //     currentLinks: cola.links()
  //   }
  //
  //   function navigateToNode () {
  //
  //   }
  //   this.props.actions.setNodeMap(currentNodes)
  //   this.animateNodes(animateOptions) //transition to new positions
  // },

  getHref: function (model) {
    return router.format({ id: model.id })
  },

  navigate: router.navigate.bind(router),

  handleClick: function (model) {
    var self = this
    return function () {
      debug('handleClick', model)
      self.navigate(self.getHref(model))
    }
  }
})
