var keys = require('lodash.keys')
var pluck = require('lodash.pluck')
var contains = require('lodash.contains')
var map = require('lodash.map')

var intersection = require('lodash.intersection')
var debug = require('debug')('graph-view:format-graph-data2')
var Url = require('url')
var find = require('lodash.find')
var isUrl = require('is-url-superb')
var clone = require('lodash.clone')
var keys = require('lodash.keys')
var reject = require('lodash.reject')

var config = require('config')
var prefix = Url.format(config.api)
var vars = require('ui/vars')

var dot = require('dot-object')

//DEFAULTS
var membershipTypeId = prefix + '/relationshipTypes/membership'
var memberLinkTypeId = prefix + '/roleTypes/member/link'
var group = prefix + '/roleTypes/group'
var groupLinkTypeId = group + '/link'
var member = prefix + '/roleTypes/member'
var subgroup = prefix + '/roleTypes/subgroup'

function getLinkLength (n, l) {
  return (1+(n-1)*0.2)*l
}

function shortId (longId) {
  return longId.slice(prefix.length)
}

function setNodeQueryMap (nodeIds, query, nodeQueryMap) {
  nodeIds.forEach(function (nodeId) {
    if (nodeQueryMap[nodeId]) { nodeQueryMap[nodeId][query.id] = query }
    else {
      nodeQueryMap[nodeId] = {}
      nodeQueryMap[nodeId][query.id] = query
    }
  })
}

module.exports = function (model, queries, centerCoords, optionsMap) {
  var optionsMap = optionsMap || {}
  var queryMap = queries.queryMap
  var nodes = []
  var links = []
  var nodeIds = {}
  var idToIndex = {}
  idToIndex[model.getId()] = 0
  var activeHalosMap = {}
  var nodeQueryMap = {}
  var counter = 1
  var linkLength = Math.max(queries.active.length-1, 1)
  var linkQueries = {}
  var hiddenLinkQueriesToNodes = {}
  var defaults = (model.parentGroups && model.parentGroups.length > 0) ? 2 : 1

  debug('queries', queries)

  model.relationshipGraph.forEachLink(function (link) {
  //NOTE link.data is currently the sourceRole
  //NOTE [performance]  don't need to build links which don't actually exist e.g stewardee -> steward
    if (link.data.type.linkType) {
      var query
      if (link.data.relationship.context) {
        var contextId = link.data.type.linkType.id + '.ctx.' + link.data.relationship.context.id
        query = queryMap[contextId]
        if (query) {
          setNodeQueryMap([link.fromId, link.toId], query, nodeQueryMap)
        }
      }
      else if (!query) {
        var sourceId = link.data.type.linkType.id + '.src.' + shortId(link.fromId)
        query = queryMap[sourceId]
        if (query) {
          setNodeQueryMap([link.toId], query, nodeQueryMap)
        }
        else {
          var targetId = link.data.type.linkType.id + '.tgt.' + shortId(link.toId)
          query = queryMap[targetId]
          if (query) {
            setNodeQueryMap([link.fromId], query, nodeQueryMap)
          }
        }
      }

      if (query) {
        if (typeof idToIndex[link.fromId] !== 'number') {
          idToIndex[link.fromId] = counter
          counter ++
        }
        if (typeof idToIndex[link.toId] !== 'number') {
          idToIndex[link.toId] = counter
          counter ++
        }

        if (query.showLink) { linkQueries[query.id] = query }
        else if (!query.isParent) { hiddenLinkQueriesToNodes[query.id] = [] }

        link.query = query
        link.length = getLinkLength(linkLength, 120)
        link.source = idToIndex[link.fromId]
        link.target = idToIndex[link.toId]
        links.push(link)
      }
    }
  })

  model.relationshipGraph.forEachNode(function (node) {
    if (typeof idToIndex[node.id] === 'number') {
      node.queryIds = keys(nodeQueryMap[node.id])

      if (model.parentGroups
        && model.parentGroups.length > 0
        && model.parentGroups[0].getId() === node.id) {
        node.w = vars.nodeSizes.parent
        node.h = vars.nodeSizes.parent
        node.x = vars.graphSize.width/2
        node.y = 0
        node.fixed = true
      }
      else if (model.getId() === node.id) {
        node.w = vars.nodeSizes.contextAgent
        node.h = vars.nodeSizes.contextAgent
        node.x = centerCoords[0]
        node.y = centerCoords[1]
        node.fixed = true
      }
      else {
        node.w = vars.nodeSizes.default
        node.h = vars.nodeSizes.default

        node.queryIds.forEach(function (queryId) {
          if (hiddenLinkQueriesToNodes[queryId]) {
            hiddenLinkQueriesToNodes[queryId].push(node)
          }
        })
      }

      if (optionsMap[node.id]) {
        node.x = optionsMap[node.id].x
        node.y = optionsMap.y
      }

      node.activeHalosById = activeHalosMap[node.id]
      node.activeHalos = keys(node.activeHalosById)
      nodes[idToIndex[node.id]] = node
    }

  })

//halo case
//some nodes have 1 query (not parent)
// some nodes have >1 queries with showLink:false
  //-> nodes with >1 showLink:false have active Halos

//nodes have 1 of several distinct active showLink:false queries

  debug('hiddenLinkQueriesToNodes', hiddenLinkQueriesToNodes)
  var hiddenLinkQueries = keys(hiddenLinkQueriesToNodes)
  if (hiddenLinkQueries.length > 1) {
    hiddenLinkQueries.forEach(function (queryId) {
      if (hiddenLinkQueriesToNodes[queryId].length < nodes.length - defaults) {
        //set query and node with a showHalo
        hiddenLinkQueriesToNodes[queryId].forEach(function (node) {
          if (nodes[idToIndex[node.id]].activeHalosById) {
            nodes[idToIndex[node.id]].activeHalosById
          }
        })
      }

    })

  }


  //remove excess hidden links
  reject(links, function (link) {
    if (link.query.component.relationshipType.id === '/relationshipTypes/membership') {
      if (link.query.source && link.query.source.id === model.id
        || link.query.target && link.query.target.id === model.id) {
        return true
      }
      else { return false }
    }
    else { return false }
  })


  debug('nodes', nodes, idToIndex)
  return [nodes, links, activeHalosMap]
}
