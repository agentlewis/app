var keys = require('lodash.keys')
var pluck = require('lodash.pluck')
var contains = require('lodash.contains')
var map = require('lodash.map')

var intersection = require('lodash.intersection')
var debug = require('debug')('graph-view:formatGraphData')
var Url = require('url')
var find = require('lodash.find')
var isUrl = require('is-url-superb')
var thenify = require('thenify')

var config = require('config')
var prefix = Url.format(config.api)
var vars = require('ui/vars')

//DEFAULTS
var membershipTypeId = prefix + '/relationshipTypes/membership'
var memberLinkTypeId = prefix + '/roleTypes/member/link'
var groupLinkTypeId = prefix + '/roleTypes/group/link'
var member = prefix + '/roleTypes/member'


function getSourceRole (roles, sourceId) {
  for (var i=0; i< roles.length; i++) {
    if(roles[i].agent.getId() === sourceId) return roles[i]
  }
}

function getLinkLength (n, l) {
  return (1+(n-1)*0.2)*l
}

function nodeInSubject (node, triple) {
  var subject = triple.subject || {}
  var object = triple.object || {}
  if (subject.active && subject.agentType === node.data['@type']) { //matching agentType
    if (node.data.rolesByType[subject.roleType]) { //matching role
      return node.data.rolesByType[subject.roleType].reduce(function (memo, role) {
        if (role.linkTargetId === object.id) memo = true //matching target
        return memo
      }, false)
    } else {  return false  }
  } else {  return false  }
}

function nodeInFilter(node, activeRoleFilters, activeRelationships) {
  var roleMatches = getRoleMatches(node, activeRoleFilters)
  if (roleMatches.length > 0) return true
  debug('activeRelationships', activeRelationships)
  if (activeRelationships.length === 0) return false
  return node.data.relationships.reduce(function (memo, relationship) {
    debug('relationship', relationship)
    if (contains(activeRelationships, relationship.type.getId())) memo = true
    return memo
  }, false)
}

function nodeIsParent(node, model) {
  if (model['@type'] === 'Group' && model.parentGroups.length > 0) {
    return model.parentGroups.reduce(function (memo, parent) {
      if (parent.getId() === node.id) {
        memo = true
      }
      return memo
    }, false)
  }
  else { return false }
}

function linkIsActiveFilter (linkTypeId, filters) {
  return filters.reduce(function (memo, filter) {
    if (filter.active && filter.type === 'Link' && filter.linkTypeId === linkTypeId ) {
      memo = { color: filter.color }
    }
    return memo
  }, false)
}

function linkIsActiveTriple (linkTypeId, triple) {
  if (triple.predicate.active && triple.predicate.linkTypeId === linkTypeId) {
    return { color: triple.predicate.color, hidden: false }
  }
  if (triple.subject.active && triple.subject.linkTypeId === linkTypeId) {
    return { color: triple.subject.color, hidden: true }
  }
  return false
}

function hiddenLink(link, idToIndex) {
  if (idToIndex[link.data.agent.getId()] && link.data.type.getId() === member) return true
  return false
}

function makeUINode (node, options) {
  debug('makeUINode', node, options)
  var coords = options.coords || [0, 0]
  var uiNode = {
    activeRoleTypes: options.activeRoleTypes || [],
    id: node.id,
    model: node.data,
    w: options.size || 40,
    h: options.size || 40,
    fixed: options.fixed || false,
    IdMap: options.IdMap
  }
  if (options.coords) {
    uiNode.x = coords[0]
    uiNode.y = coords[1]
  }
  return uiNode
}

function makeUILink (link, options) {
  var length = options.length || 100
  var hidden = options.hidden
  var source = options.source
  var target = options.target
  var color = options.color
  return {
    id: link.id,
    hidden: hidden,
    source: source,
    target: target,
    model: link.data,
    color: color,
    length: length
  }
}

function getRoleMatches (node, activeRoleFilters) {
  var nodeRoleTypeIds = map(node.data.roles, function (role) { return role.type.getId() })
  return intersection(activeRoleFilters, nodeRoleTypeIds)
}

module.exports = function (model, tagData, centerCoords, options) {
  var graph = model.relationshipGraph
  var contextAgentId = model.getId()
  var nodes = []
  var links = []
  var filters = tagData.filters || []
  var triple = tagData.triple || {}
  var subject = triple.subject
  var object = triple.object
  var IdMap = {}
  var idToIndex = {}
  var activeRoleFilters = []
  var activeLinkFilters = []
  var activeRelationships = []
  var isMembershipLinkActive
  var hiddenMemberLink

  debug('filters', filters)
  //extract active Roles and Links and map to a singleton
  keys(triple).forEach(function (key) {
    var expression = triple[key]
    if (expression.active && expression.type === 'Link') activeRelationships.push(expression.relationshipTypeId)
    IdMap[expression.id] = expression
  })

  for (var i=0, len = filters.length; i<len; i++) {
    var filter = filters[i]
    if (filter.active) {
      debug('active filter', filter)
      if (filter.type === 'Role') { activeRoleFilters.push(filter.id) }
      else { //type is 'Link'
        activeLinkFilters.push(filter.linkTypeId)
        activeRelationships.push(filter.relationshipTypeId)
      }
      IdMap[filter.id] = filter
    }
  }

  debug('activeRelationships', activeRelationships, activeRoleFilters)

  isMembershipLinkActive = contains(activeLinkFilters, function (id) {
    return memberLinkTypeId || groupLinkTypeId
  })

  hiddenMemberLink = (!isMembershipLinkActive && activeLinkFilters.length === 0)

  graph.forEachNode(function (node) {
    //if node is contextAgent -> active, centered, big
    //else if node is parentGroup of contextAgent -> active, top, v.big
    //else if node.role matches triple -> active, regular
    //else if node.role  matches filter.role TODO: && same node.role.link.target target matches filter target
    var coords = (options && options[node.id]) ? options[node.id] : null
    if (node.id === contextAgentId) {
      nodes.push(makeUINode(
        node,
        {
          size: vars.nodeSizes.contextAgent,
          activeRoleTypes: getRoleMatches(node, activeRoleFilters),
          IdMap: IdMap,
          fixed: true,
          coords:  centerCoords
        })
      )
      idToIndex[node.id] = nodes.length -1
      return
    }
    var isParentNode = nodeIsParent(node, model)
    if (isParentNode) {
      nodes.push(makeUINode(
        node,
        {
          size: vars.nodeSizes.parent,
          activeRoleTypes: getRoleMatches(node, activeRoleFilters),
          IdMap: IdMap,
          coords: [centerCoords[0], 0],
          fixed: true
        }
      ))
      idToIndex[node.id] = nodes.length -1
      return
    }
    var isSubjectNode = nodeInSubject(node, triple)
    if (isSubjectNode) {
      nodes.push(makeUINode(
        node,
        {
          size: vars.nodeSizes.default,
          activeRoleTypes: getRoleMatches(node, activeRoleFilters),
          IdMap: IdMap ,
          coords: coords
        }))
      idToIndex[node.id] = nodes.length -1
      return
    }
    var isFilterNode = nodeInFilter(node, activeRoleFilters, activeRelationships)
    if (isFilterNode) {
      nodes.push(makeUINode(
        node,
        {
          size: vars.nodeSizes.default,
          activeRoleTypes: getRoleMatches(node, activeRoleFilters),
          IdMap: IdMap,
          coords: coords
        }
      ))
      idToIndex[node.id] = nodes.length -1
      return
    }
  })
  debug('nodes', idToIndex, nodes)

  graph.forEachLink(function (link) {
    var fromId = link.fromId
    var source = idToIndex[fromId]
    var target = idToIndex[link.toId]
    if (typeof source === 'undefined' || typeof target === 'undefined') { return }

    var linkTypeId = link.data.linkTypeId

    var isLinkActiveFilter = linkIsActiveFilter(linkTypeId, filters)
    if (isLinkActiveFilter) {
      links.push(makeUILink(
        link,
        {
          length: getLinkLength(activeLinkFilters.length, 100),
          hidden: false,
          source: source,
          target: target,
          color: isLinkActiveFilter.color
        }))
      return
    }
    var isLinkActiveTriple = linkIsActiveTriple(linkTypeId, triple)
    if (isLinkActiveTriple) {
      links.push(makeUILink(
        link,
        {
          length: getLinkLength(activeLinkFilters.length, 120),
          hidden: isLinkActiveTriple.hidden,
          source: source,
          target: target,
          color: isLinkActiveTriple.color
        }))
      return
    }
    var isLinkhidden = hiddenLink(link, idToIndex)
    if (isLinkhidden) {
      links.push(makeUILink(
        link,
        {
          length: getLinkLength(activeLinkFilters.length, 120),
          hidden: true,
          source: source,
          target: target,
          color: isLinkActiveTriple.color
        }))
      return
    }
  })


  return [nodes, links, idToIndex]
}
