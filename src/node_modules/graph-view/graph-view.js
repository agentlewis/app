var React 	= require('react');
var _ = require('lodash');
var traverse = require('traverse');
var debug = require('debug')("graph-view");
//takes node and edge data and out node and edge svgs

var h = require('create-element');

var info = require('debug')("graph-view - info");

var Cola = require('graph-view/webcola-adaptor')();
var Node 		= require('graph-view/node-ui');
var Edge 		= require('graph-view/edge-ui');

function makeLink (subj, relationship, obj) {
return {
	source: subj.index,
	target: obj.index,
	model: relationship
};
};

module.exports = React.createClass({

	getInitialState: function (options) {
		var predicates		= this.props.predicates || []
		 , 	model 				= this.props.model;

		 var nodes				= model.relatedNodes
		 ,	edges 				= model.relatedEdges
		 ,	relationships	= model.relationships.models
		 ,	links 				= [];

		nodes.forEach(function (entity, i) { entity.index = i });

		//compute links
		for (var i=0;i<predicates.length;i++) {
			var predicate 	= predicates[i];
			var subjectIds 	= edges[predicate];
			debug({subjectIds: subjectIds, predicate: predicate, edges: edges })
			if (subjectIds) {
				Object.keys(subjectIds).forEach(function (subjId) {
					var subject 	= _.find(nodes, function (node) { if (node._values) return node._values["@id"] === subjId; });
					var objectIds = edges[predicate][subjId];
					for (var j=0;j<objectIds.length;j++) {
						var objId = objectIds[j];
						var object 				= _.find(nodes, function (node) { if (node._values) return node._values["@id"] === objId; });
						var relationship 	= _.find(object.relationships.models, function (rel) {
							if (rel._values) return (rel._values.is === subjId && rel._values.has === objId);
						});
						if (object) links.push(makeLink(subject, relationship, object));
					}
				})				
			}
		}

		var width 	= 700,
				height 	= 700;

		var cola = Cola
			.size([width, height])
			.avoidOverlaps(true)
			.linkDistance(70)
			// .nodes(nodes)
			// .links(links)

		return {
			width: width,
			height: height,
			cola: cola,
			rect: {
				top: null,
				left: null				
			}
		}
	},

	render: function () {
		var nodes = this.state.cola.nodes();
		var edges = this.state.cola.links();
		var actions = this.props.actions;

		debug('rendering', { props: this.props })
		debug('rendering nodes', { nodes: nodes })
		return(
			React.createElement("div", null, 
				React.createElement('div', { className: 'node-group' },
					this.state.rect
						? nodes.map(function (node) {
							return React.createElement(Node, { datum: node, actions: actions, key: node.id, rect: this.state.rect })
							}.bind(this))
						: null
				),
				React.createElement("svg", 
					{
						id: 'graph-view-svg',
						width: this.state.width, 
						height: this.state.height 
					}, 
					React.createElement("defs"),
					// React.createElement("g", {className: "node-group"}, 
					// 	nodes.map(function (node) {
					// 		return React.createElement(Node, { datum: node, actions: actions, key: node.id })
					// 	})
					// ), 
					React.createElement("g", {className: "edge-group"}, 
						edges.map(function (edge) {
							return React.createElement(Edge, { datum: edge, actions: actions, key: edge.id })
						})
					)
				)
			)
		);
	},

	componentDidMount: function () {
		debug('componentDidMount')
		var DOMNode = this.getDOMNode();
		var rect = DOMNode.getBoundingClientRect();
		var defs = DOMNode.getElementsByTagName('defs')[0];
		var marker = h('marker', 
			{ 
				id: 'arrowhead',
        viewBox:"0 0 10 10", 
        refX:"1", refY:"5",
        markerWidth:"6", 
        markerHeight:"6",
        orient:"auto"
			},
			h('path', { d: "M 0 0 L 10 5 L 0 10 z", fill: 'grey' })
		);

		//tick listener triggers setState, triggers re-render
		this.state.cola.on('tick', function () {
			this.setState({ nodes: this.state.cola.nodes() })
		}.bind(this));

		//trigger force graph
		this.state.cola.start();

		// find the svg coordinates in relation to the window
		debug('rect', rect)
		this.setState({ rect: { top: rect.top, 	left: rect.left } });

		//insert our arrowhead marker 'cos React doesn't support it? :(
		defs.insertAdjacentHTML('beforeend', marker)
	},

	componentWillReceiveProps: function (nextProps) {
		debug('componentWillReceiveProps', {nextProps: nextProps});
		var predicates		= nextProps.predicates || []
		 , 	model 				= nextProps.model;

		 var nodes				= model.relatedNodes
		 ,	edges 				= model.relatedEdges
		 ,	relationships	= model.relationships.models
		 ,	links 				= [];

		 debug('info', {nodes: nodes, edges: edges, model: model})

		if (nodes.length > 0) {
			nodes.forEach(function (entity, i) { entity.index = i });
			for (var k=0;k<nodes.length;k++) {
				var node = nodes[k];
				debug('node', node._values, node)
			}


			for (var i=0;i<predicates.length;i++) {
				var predicate 	= predicates[i];
				var subjectIds 	= edges[predicate];
				debug({subjectIds: subjectIds, predicate: predicate, edges: edges })
				if (subjectIds) {
					Object.keys(subjectIds).forEach(function (subjId) {



						var subject 	= _.find(nodes, function (node) {  if (node._values) { return node._values["@id"] === subjId; } });
						debug('subject', subject, subjId)
						var objectIds = edges[predicate][subjId];
						for (var j=0;j<objectIds.length;j++) {
							var relationship;
							var objId = objectIds[j];
							var object 				= _.find(nodes, function (node) { if (node._values) return node._values["@id"] === objId; });
							if (object) {
								relationship 	= _.find(object.relationships.models, function (rel) {
									if (rel._values) return (rel._values.is === subjId && rel._values.has === objId);
								});
								links.push(makeLink(subject, relationship, object));
							}
						}
					})				
				}
			}
		var cola = this.state.cola.nodes(nodes).links(links);
		this.setState({ cola: cola })
		this.state.cola.start()

		}

		debug({links: links})






	},

	// shouldComponentUpdate: function (nextProps, nextState) {
	// 	//TODO use immutable.js
	// 	//Test if new data recieved, if true rerender
	// 	// if (nextProps.nodes === this.props.nodes 
	// 	// 		|| nextProps.edges === this.props.edges) return false;
	// 	// else return true;
	// 	return true;
	// },

	componentWillUpdate: function (nextProps, nextState) {




	}





})

