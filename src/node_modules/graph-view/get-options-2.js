var store = require('base/store')
var Labels = require('./labels')
var clone = require('lodash.clone')
var keys = require('lodash.keys')
var isArray = require('lodash.isarray')
var pluck = require('lodash.pluck')
var dot = require('dot-object')
var obj   = require('lodash.zipobject')
var debug = require('debug')('graph-view:get-options-2')
var Url = require('url')
var config = require('config')
var prefix = Url.format(config.api)
var parentGroup = prefix + '/roleTypes/parent-group'

function makeTag (options) {
  var agent = options.source || options.target || options.context
  return {
    type: options.component['@type'],
    agentId: agent.getId(),
    id: [
      options.component['@type'] +':' + options.component.id,
      options.source ? 'src:' + options.source.id : null,
      options.target ? 'tgt:' + options.target.id : null,
      options.context ? 'ctx:' + options.context.id : null
    ].join('_'),
    label: options.context ? options.component.inContextLabel.format({ context: options.context.name }) : options.component.label.format({
      source: dot.pick('source.name', options) || dot.pick('source.agent.name', options),
      target: dot.pick('target.name', options) || dot.pick('target.agent.name', options),
    }),
    linkTypeId: options.component['@type'] === 'LinkType' ? options.component.id : null,
    roleTypeId: options.component['@type'] === 'RoleType' ? options.component.id : null,
  }
}

module.exports = function (model, activeQueries) {
  var options = []
  var tags = []
  var contextRelationshipTypes = {}
  var roleTypes = {}
  var contextLinkTypes = {}
  var linkTypes = {}

  debug('activeQueries', activeQueries)

  model.roles.forEach(function (role) {
    if (role.type.linkType && !linkTypes[role.type.linkType.id]) {
      if (!dot.pick(role.type.linkType.id + '.targets.' + model.id, activeQueries)) { //not active
        options.push(makeTag({ source: model,  component: role.type.linkType }))
      }
      else {
        tags.push(makeTag({ source: model, component: role.type.linkType }))
      }
      linkTypes[role.type.linkType.id] = role.type.linkType
    }
  })

  model.sourceRoles.forEach(function (sourceRole) {
    if (!roleTypes[sourceRole.type.id]) {
      if (!dot.pick(sourceRole.type.id + '.targets.' + model.id, activeQueries)) { //not active
        debug('sourceRole', sourceRole.type.id, sourceRole)
        options.push(makeTag({ target: model,  component: sourceRole.type }))
        if (sourceRole.type.linkType && !linkTypes[sourceRole.type.linkType.id]) {
          if (!dot.pick(sourceRole.type.linkType.id + '.targets.' + model.id, activeQueries)) { //not active
            options.push(makeTag({ target: model,  component: sourceRole.type.linkType }))
          }
          else {
            tags.push(makeTag({ target: model,  component: sourceRole.type.linkType }))
          }
          linkTypes[sourceRole.type.linkType.id] = sourceRole.type.linkType
        }
      }
      roleTypes[sourceRole.type.id] = sourceRole.type
    }
  })

  //TODO logic not quite right
  model.targetRoles.forEach(function (targetRole) {
    if (!roleTypes[targetRole.type.id]) {
      if (!dot.pick(targetRole.id + '.sources.' + model.id, activeQueries)) {  //not active
        debug('targetRole', targetRole.type.name, targetRole)
        options.push(makeTag({ source: model,  component: targetRole.type }))

        if (targetRole.type.linkType && !linkTypes[targetRole.type.linkType.id]) {
          if (!dot.pick(targetRole.type.linkType.id + '.sources.' + model.id, activeQueries)) {
            options.push(makeTag({ target: model,  component: targetRole.type.linkType }))
          }
          else {
            tags.push(makeTag({ target: model,  component: targetRole.type.linkType }))
          }

          linkTypes[targetRole.type.linkType.id] = targetRole.type.linkType
        }

        roleTypes[targetRole.type.id] = targetRole.type
      }
      else {
        tags.push({ source: model,  component: targeRole.type })
      }
    }
  })

  model.contextRelationships.forEach(function (relationship) {
    if (!contextRelationshipTypes[relationship.type.id]) {
      relationship.roles.forEach(function (role) {
        if (!roleTypes[role.type.id]) {
          if(!dot.pick(role.type.id + '.contexts.' + model.id, activeQueries)) {
            options.push(makeTag({ context: model,  component: role.type }))
          }
          else {
            tags.push(makeTag({ context: model,  component: role.type }))
          }

          roleTypes[role.type.id] = role.type
        }
      })

      relationship.type.linkTypes.forEach(function (linkType) {
        if (!contextLinkTypes[linkType.id]) {
          if(!dot.pick(linkType.id + '.contexts.' + model.id, activeQueries)) {
            options.push(makeTag({ context: model,  component: linkType }))
          }
          else {
            tags.push(makeTag({ context: model,  component: linkType }))
          }
          contextLinkTypes[linkType.id] = linkType
        }

      })

      contextRelationshipTypes[relationship.type.getId()] = relationship.type
    }
  })







  debug('options', options, model)
  //option: role + target; link + target; role + context; agentType + target;
    //agentType
    //roleType
      //halo
    //linkType
    //agentType
    //context || target


  return options
}


//people that follow charlie "role: follower target: charlie"
//people that charlie follows "role: follower", source: charlie"
