// TODO use intersection for halo logic?
// var intersection = require('lodash.intersection')
var debug = require('debug')('graph-view:format-graph-and-query')
var Url = require('url')
var each = require('lodash.foreach')
var keys = require('lodash.keys')
var reject = require('lodash.reject')

var config = require('config')
var prefix = Url.format(config.api)
var sortActiveQueries = require('graph-view/sort-active-queries')
var vars = require('ui/vars')

function shortId (longId) {
  return longId.slice(prefix.length)
}

function setNodeQueryMap (nodeIds, query, nodeQueryMap) {
  nodeIds.forEach(function (nodeId) {
    if (nodeQueryMap[nodeId]) {
      nodeQueryMap[nodeId][query.id] = query
    } else {
      nodeQueryMap[nodeId] = {}
      nodeQueryMap[nodeId][query.id] = query
    }
  })
}

module.exports = function (model, queries, centerCoords, optionsMap) {
  optionsMap = optionsMap || {}
  var queryMap = queries.queryMap
  var nodes = []
  var links = []
  var idToIndex = {}
  var nodeQueryMap = {}
  var linkQueries = {}
  var hiddenLinkQueriesToNodes = {}
  var counter = 1
  queries.active = []
  idToIndex[model.getId()] = 0
  debug('queryMap', queryMap)
  debug('centerCoords', centerCoords)

  model.relationshipGraph.forEachLink(function (link) {
    // debug('link', link)
  // NOTE link.data is currently the sourceRole
  // NOTE [performance]  don't need to build links which don't actually exist e.g stewardee -> steward
    if (link.data.linkType && link.data.sourceRole) {
      var query
      if (link.data.sourceRole.relationship.context) {
        var contextId = link.data.linkType.id + '.ctx.' + link.data.sourceRole.relationship.context.id
        query = queryMap[contextId]
        if (query) {
          if (typeof idToIndex[link.fromId] !== 'number') {
            idToIndex[link.fromId] = counter
            counter++
          }
          if (query.showLink) {
            setNodeQueryMap([link.fromId, link.toId], query, nodeQueryMap)
            if (typeof idToIndex[link.toId] !== 'number') {
              idToIndex[link.toId] = counter
              counter++
            }
          } else { setNodeQueryMap([link.fromId], query, nodeQueryMap) }
        }
      }
      if (!query) {
        var sourceId = link.data.linkType.id + '.src.' + shortId(link.fromId)
        query = queryMap[sourceId]
        if (query) {
          setNodeQueryMap([link.toId], query, nodeQueryMap)
          if (typeof idToIndex[link.toId] !== 'number') {
            idToIndex[link.toId] = counter
            counter++
          }
        } else {
          var targetId = link.data.linkType.id + '.tgt.' + shortId(link.toId)
          query = queryMap[targetId]
          if (query) {
            setNodeQueryMap([link.fromId], query, nodeQueryMap)
            if (typeof idToIndex[link.fromId] !== 'number') {
              idToIndex[link.fromId] = counter
              counter++
            }
          }
        }
      }

      if (query) {
        debug('query', query)

        if (query.showLink) {
          linkQueries[query.id] = query
        } else if (!query.isParent) { hiddenLinkQueriesToNodes[query.id] = [] }

        link.query = query
        link.source = idToIndex[link.fromId]
        link.target = (query.context && !query.showLink) ? 0 : idToIndex[link.toId] // hidden Link
        links.push(link)
      }
    }
  })

  model.relationshipGraph.forEachNode(function (node) {
    if (typeof idToIndex[node.id] === 'number') {
      node.queryIds = keys(nodeQueryMap[node.id])
      node.activeHalos = []
      node.activeHalosById = {}

      if (model.parentGroups &&
        model.parentGroups.length > 0 &&
        model.parentGroups[0].getId() === node.id) {

        node.w = vars.nodeSizes.parent
        node.h = vars.nodeSizes.parent
        node.x = centerCoords[0]
        node.y = 0
        node.fixed = true
      } else if (model.getId() === node.id) {
        node.w = vars.nodeSizes.contextAgent
        node.h = vars.nodeSizes.contextAgent
        node.x = centerCoords[0]
        node.y = centerCoords[1]
        node.fixed = true

        debug('context node', node, centerCoords)
      } else {
        node.w = vars.nodeSizes.default
        node.h = vars.nodeSizes.default

        node.queryIds.forEach(function (queryId) {
          if (hiddenLinkQueriesToNodes[queryId]) {
            hiddenLinkQueriesToNodes[queryId].push(node)
          }
          queryMap[queryId].nodes.push(node)
        })
      }

      if (optionsMap[node.id]) {
        node.x = optionsMap[node.id].x
        node.y = optionsMap.y
      }

      nodes[idToIndex[node.id]] = node
    }
  })

  // fill out active queries array and sort
  keys(queryMap).forEach(function (queryId) {
    queries.active.push(queryMap[queryId])
  })
  queries.active.sort(sortActiveQueries)

// NOTE halo cases -wip
// some nodes have 1 query (not parent)
// some nodes have >1 queries with showLink:false
  // -> nodes with >1 showLink:false have active Halos

// nodes have 1 of several distinct active showLink:false queries

  debug('hiddenLinkQueriesToNodes', hiddenLinkQueriesToNodes)
  debug('queryMap', queryMap)
  // compute showHalo logic
  var hiddenLinkQueries = keys(hiddenLinkQueriesToNodes)
  var maxNodeCount = 0
  var equalCounts = false
  var haloLimit = queryMap['/linkTypes/is-part-of.src.' + model.id] ? 2 : 1
  each(hiddenLinkQueriesToNodes, function (hiddenLinkNodes) {
    if (hiddenLinkNodes.length > 0 && hiddenLinkNodes.length === maxNodeCount) {
      equalCounts = true
    } else if (hiddenLinkNodes.length > maxNodeCount) {
      maxNodeCount = hiddenLinkNodes.length
    }
  })
  debug('maxNodeCount', maxNodeCount, equalCounts, queries.active)

  each(hiddenLinkQueriesToNodes, function (hiddenLinkNodes, queryId) {
    debug('hlq', hiddenLinkNodes.length, queryId)
    if (hiddenLinkNodes.length < maxNodeCount ||
      (hiddenLinkQueries.length > haloLimit) ||
        (hiddenLinkNodes.length === maxNodeCount && equalCounts)) {

      queryMap[queryId].showHalo = true

      // set query and node with a showHalo
      hiddenLinkNodes.forEach(function (node) {
        nodes[idToIndex[node.id]].activeHalosById[queryId] = queryMap[queryId]
        nodes[idToIndex[node.id]].activeHalos.push(queryId)
      })
    }
  })

  // remove excess hidden links
  reject(links, function (link) {
    if (link.query.component.relationshipType.id === '/relationshipTypes/membership') {
      if (link.query.source && link.query.source.id === model.id ||
      link.query.target && link.query.target.id === model.id) {
        return true
      } else { return false }
    } else { return false }
  })

  // set link lengths
  links = links.map(function (link) {
    link.length = vars.graphSize.defaultLength + Math.pow(links.length, 0.7)
    return link
  })

  debug('nodes', nodes, links, idToIndex)
  return [nodes, links, queries, hiddenLinkQueries.length]
}
