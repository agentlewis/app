var debug = require('debug')('graph-view:format-graph-and-query')
var Url = require('url')
var each = require('lodash.foreach')
var keys = require('lodash.keys')
var reject = require('lodash.reject')

var config = require('config')
var prefix = Url.format(config.api.url)
var sortActiveQueries = require('graph-view/sort-active-queries')
var vars = require('ui/vars')
var haloLogic = require('./halo-logic')

function shortId (longId) {
  return longId.slice(prefix.length)
}

function setNodeQueryMap (nodeIds, query, nodeQueryMap) {
  nodeIds.forEach(function (nodeId) {
    if (nodeQueryMap[nodeId]) {
      nodeQueryMap[nodeId][query.id] = query
    } else {
      nodeQueryMap[nodeId] = {}
      nodeQueryMap[nodeId][query.id] = query
    }
  })
}

module.exports = function (model, queries, centerCoords, optionsMap) {
  optionsMap = optionsMap || {}
  var queryMap = queries.queryMap
  var nodes = []
  var links = []
  var idToIndex = {}
  var nodeQueryMap = {}
  var linkQueries = {}
  var linkQueriesToNodes = {}
  var counter = 1
  queries.active = []
  idToIndex[model.getId()] = 0
  debug('queryMap', queryMap)
  debug('centerCoords', centerCoords)

  model.relationshipGraph.forEachLink(function (link) {
    // debug('link', link)
  // NOTE link.data is currently the sourceRole
  // NOTE [performance]  don't need to build links which don't actually exist e.g stewardee -> steward
    if (link.data.linkType && link.data.sourceRole) {
      var query
      if (link.data.sourceRole.relationship.context) {
        var contextId = link.data.linkType.id + '.ctx.' + link.data.sourceRole.relationship.context.id
        query = queryMap[contextId]
        debug('query', query)
        if (query) {
          if (typeof idToIndex[link.fromId] !== 'number') {
            idToIndex[link.fromId] = counter
            counter++
          }
          if (query.showLink) {
            setNodeQueryMap([link.fromId, link.toId], query, nodeQueryMap)
            if (typeof idToIndex[link.toId] !== 'number') {
              idToIndex[link.toId] = counter
              counter++
            }
          } else { setNodeQueryMap([link.fromId], query, nodeQueryMap) }
        }
      }
      if (!query) {
        var sourceId = link.data.linkType.id + '.src.' + shortId(link.fromId)
        query = queryMap[sourceId]
        if (query) {
          setNodeQueryMap([link.toId], query, nodeQueryMap)
          if (typeof idToIndex[link.toId] !== 'number') {
            idToIndex[link.toId] = counter
            counter++
          }
        } else {
          var targetId = link.data.linkType.id + '.tgt.' + shortId(link.toId)
          query = queryMap[targetId]
          if (query) {
            setNodeQueryMap([link.fromId], query, nodeQueryMap)
            if (typeof idToIndex[link.fromId] !== 'number') {
              idToIndex[link.fromId] = counter
              counter++
            }
          }
        }
      }

      if (query) {
        debug('query', query)
        if (query.showLink) { linkQueries[query.id] = query }
        if (!query.isParent) { linkQueriesToNodes[query.id] = [] }

        link.query = query
        link.source = idToIndex[link.fromId]
        link.target = (query.context && !query.showLink) ? 0 : idToIndex[link.toId] // hidden Link
        links.push(link)
      }
    }
  })

  model.relationshipGraph.forEachNode(function (node) {
    if (typeof idToIndex[node.id] === 'number') {
      node.queryIds = keys(nodeQueryMap[node.id])
      node.activeHalos = []
      node.activeHalosById = {}

      if (model.parentGroups &&
        model.parentGroups.length > 0 &&
        model.parentGroups[0].getId() === node.id) {

        node.w = vars.nodeSizes.parent
        node.h = vars.nodeSizes.parent
        node.x = centerCoords[0]
        node.y = 0
        node.fixed = true
      } else if (model.getId() === node.id) {
        node.w = vars.nodeSizes.contextAgent
        node.h = vars.nodeSizes.contextAgent
        node.x = centerCoords[0]
        node.y = centerCoords[1]
        node.fixed = true

        debug('context node', node, centerCoords)
      } else {
        node.w = vars.nodeSizes.default
        node.h = vars.nodeSizes.default

        node.queryIds.forEach(function (queryId) {
          if (linkQueriesToNodes[queryId]) {
            linkQueriesToNodes[queryId].push(node)
          }
          queryMap[queryId].nodes.push(node)
        })
      }

      if (optionsMap[node.id]) {
        node.x = optionsMap[node.id].x
        node.y = optionsMap.y
      }

      nodes[idToIndex[node.id]] = node
    }
  })

  // fill out active queries array and sort
  keys(queryMap).forEach(function (queryId) {
    queries.active.push(queryMap[queryId])
  })
  queries.active.sort(sortActiveQueries)

  var haloMatches = haloLogic(linkQueriesToNodes)
  debug('haloMatches', haloMatches)
  each(haloMatches, function (nodesWithHalos, queryId) {
    queryMap[queryId].showHalo = true
    nodesWithHalos.forEach(function (nodeId) {
      nodes[idToIndex[nodeId]].activeHalosById[queryId] = queryMap[queryId]
      nodes[idToIndex[nodeId]].activeHalos.push(queryId)
    })
  })

  // remove excess hidden links
  reject(links, function (link) {
    if (link.query.component.relationshipType.id === '/relationshipTypes/membership') {
      if (link.query.source && link.query.source.id === model.id ||
      link.query.target && link.query.target.id === model.id) {
        return true
      } else { return false }
    } else { return false }
  })

  // set link lengths
  links = links.map(function (link) {
    link.length = vars.graphSize.defaultLength + Math.pow(links.length, 0.7)
    return link
  })

  debug('nodes', nodes, links, idToIndex)
  return [nodes, links, queries, linkQueries.length]
}
