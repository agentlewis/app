var debug = require('debug')('graph-view:format-graph-and-query')
var Url = require('url')
var each = require('lodash.foreach')
var keys = require('lodash.keys')
var reject = require('lodash.reject')

var config = require('config')
var prefix = Url.format(config.api.url)
var sortActiveQueries = require('graph-view/sort-active-queries')
var vars = require('ui/vars')
var haloLogic = require('./halo-logic')

function nonGreedy (queryId, nodeId, nonGreedyQueryNodes, nonGreedyMap) {
  if (queryId.split('.')[0] === '/linkTypes/is-subgroup-of') { return }
  if (!nonGreedyQueryNodes[queryId]) { nonGreedyQueryNodes[queryId] = [] }
  if (nonGreedyMap[nodeId]) {
    nonGreedyMap[nodeId][queryId] = true
  } else {
    nonGreedyMap[nodeId] = {}
    nonGreedyMap[nodeId][queryId] = true
  }

  nonGreedyQueryNodes[queryId].push(nodeId)
}

function shortId (longId) {
  return longId.slice(prefix.length)
}

module.exports = function (model, queries, centerCoords, optionsMap) {
  optionsMap = optionsMap || {}
  var queryMap = queries.queryMap
  var nodes = []
  var links = []
  var idToIndex = {}
  // if showLink is true a greedy context query pulls in both the source and target nodes
  // nonGreedyQueryNodes keeps track of the nodes that are directly related to the query
  var nonGreedyQueryNodes = {}
  var nonGreedyMap = {}
  var linkQueries = {}
  var linkQueriesToNodeIds = {}
  var counter = 1
  queries.active = []
  idToIndex[model.getId()] = 0
  debug('queryMap', queryMap)
  debug('centerCoords', centerCoords)

  model.relationshipGraph.forEachLink(function (link) {
    // debug('link', link)
  // NOTE link.data is currently the sourceRole
  // NOTE [performance]  don't need to build links which don't actually exist e.g stewardee -> steward
    if (link.data.linkType && link.data.sourceRole) {
      var query
      if (link.data.sourceRole.relationship.context) {
        var contextId = link.data.linkType.id + '.ctx.' + link.data.sourceRole.relationship.context.id
        query = queryMap[contextId]
        debug('query', query, contextId)
        if (query) {
          if (!nonGreedyMap[link.fromId] ||
          !nonGreedyMap[link.fromId][query.id]) {
            nonGreedy(query.id, link.fromId, nonGreedyQueryNodes, nonGreedyMap)
          }
          if (typeof idToIndex[link.fromId] !== 'number') {
            debug('cotext fromId', link.fromId)
            idToIndex[link.fromId] = counter
            counter++
          }
          if (query.showLink) {
            if (typeof idToIndex[link.toId] !== 'number') {
              idToIndex[link.toId] = counter
              counter++
            }
          }
        }
      }
      if (!query) {
        var sourceId = link.data.linkType.id + '.src.' + shortId(link.fromId)
        query = queryMap[sourceId]
        if (query) {
          if (!nonGreedyMap[link.toId] ||
          !nonGreedyMap[link.toId][query.id]) {
            nonGreedy(query.id, link.toId, nonGreedyQueryNodes, nonGreedyMap)
          }
          if (typeof idToIndex[link.toId] !== 'number') {
            idToIndex[link.toId] = counter
            counter++
          }
        } else {
          var targetId = link.data.linkType.id + '.tgt.' + shortId(link.toId)
          query = queryMap[targetId]
          if (query) {
            if (!nonGreedyMap[link.fromId] ||
            !nonGreedyMap[link.fromId][query.id]) {
              nonGreedy(query.id, link.fromId, nonGreedyQueryNodes, nonGreedyMap)
            }
            if (typeof idToIndex[link.fromId] !== 'number') {
              idToIndex[link.fromId] = counter
              counter++
            }
          }
        }
      }

      if (query) {
        debug('query', query)
        if (query.showLink) { linkQueries[query.id] = query }
        if (!query.isParent) { linkQueriesToNodeIds[query.id] = [] }

        link.query = query
        link.source = idToIndex[link.fromId]
        link.target = (query.context && !query.showLink) ? 0 : idToIndex[link.toId] // hidden Link
        links.push(link)
      }
    }
  })

  model.relationshipGraph.forEachNode(function (node) {
    if (typeof idToIndex[node.id] === 'number') {
      node.queryIds = keys(nonGreedyMap[node.id])
      node.activeHalos = []
      node.activeHalosById = {}

      if (model.parentGroups &&
        model.parentGroups.length > 0 &&
        model.parentGroups[0].getId() === node.id) {

        node.w = vars.nodeSizes.parent
        node.h = vars.nodeSizes.parent
        node.x = centerCoords[0]
        node.y = 0
        node.fixed = true
      } else if (model.getId() === node.id) {
        node.w = vars.nodeSizes.contextAgent
        node.h = vars.nodeSizes.contextAgent
        node.x = centerCoords[0]
        node.y = centerCoords[1]
        node.fixed = true

      } else {
        node.w = vars.nodeSizes.default
        node.h = vars.nodeSizes.default

        node.queryIds.forEach(function (queryId) {
          queryMap[queryId].nodes.push(node)
        })
      }

      if (optionsMap[node.id]) {
        node.x = optionsMap[node.id].x
        node.y = optionsMap.y
      }

      nodes[idToIndex[node.id]] = node
    }
  })

  // fill out active queries array and sort
  keys(queryMap).forEach(function (queryId) {
    queries.active.push(queryMap[queryId])
  })
  queries.active.sort(sortActiveQueries)

  var haloMatches = haloLogic(nonGreedyQueryNodes)
  debug('haloMatches', haloMatches)
  each(haloMatches, function (nodesWithHalos, queryId) {
    queryMap[queryId].showHalo = true
    nodesWithHalos.forEach(function (nodeId) {
      nodes[idToIndex[nodeId]].activeHalosById[queryId] = queryMap[queryId]
      nodes[idToIndex[nodeId]].activeHalos.push(queryId)
    })
  })

  // remove excess hidden links
  reject(links, function (link) {
    if (link.query.component.relationshipType.id === '/relationshipTypes/membership') {
      if (link.query.source && link.query.source.id === model.id ||
      link.query.target && link.query.target.id === model.id) {
        return true
      } else { return false }
    } else { return false }
  })

  // set link lengths
  links = links.map(function (link) {
    link.length = vars.graphSize.defaultLength + Math.pow(links.length, 0.7)
    return link
  })

  debug('nodes', nodes, links, idToIndex)
  return [nodes, links, queries, linkQueries.length]
}
