var Path = require('path');
var Url = require('url');
var traverse = require('traverse-async').traverse;
var Class = require('es-class');
var each = require('async-each');
var debug = require('debug')('fs-storage');

var config = require('config');

var stripSlashes = function (name) {
  return name.replace(/^\/|\/$/g, '');
};

var serialize = function serialize (obj) {
  return JSON.stringify(obj, null, 2);
};

var deserialize = function deserialize (str) {
  return JSON.parse(str);
};

module.exports = Class({

  constructor: function (options) {

    this.collection = options.collection || "";
    this.collections = options.collections || {};
    
    this.collNamesByType = {};
    Object.keys(this.collections).forEach(function (collName) {
      var collection = this.collections[collName];
      this.collNamesByType[collection.id] = collName;
    }.bind(this));

    this.fs = options.fs || require('fs');
    this.fsRoot = options.fsRoot || config.get('data.root');

    this.extname = options.extname || ".json";
    this.serialize = options.serialize || serialize;
    this.deserialize = options.deserialize || deserialize;
  },

  path: function (collection, id) {
    debug("path(", id, ")")

    var path = Path.join(
      this.fsRoot,
      collection,
      id ? (id + this.extname) : ""
    );

    debug("path() ->", path);
    return path;
  },

  read: function (path, cb) {
    debug("read(", path, ")");
    this.fs.readFile(path, function (err, buf) {
      if (err) { return cb(err); }

      var str = buf.toString();
      debug("read raw", str);

      var obj = this.deserialize(str);

      debug("read() ->", obj);

      return cb(null, obj);
    }.bind(this));
  },

  write: {
  },

  find: function (params, cb) {
    var path = this.path(this.collection)
    return this.fs.readdir(path, function (err, dirList) {
      var ids = dirList.filter(function (name) {
        return Path.extname(name) === this.extname;
      }, this).map(function (name) {
        return Path.basename(name, this.extname);
      }, this);

      each(ids, function (id, next) {
        return this.get(id, params, next);
      }.bind(this), cb);
    }.bind(this));
  },

  get: function (id, params, cb) {
    debug("get", id, params);

    var seen = {};

    var self = this;
    var path = self.path(self.collection, id);
    return self.read(path, function (err, initObj) {
      if (err) { return cb(err); }

      seen[path] = true;

      debug("traversing object", initObj);
      var queue = traverse(initObj, function (node, next) {
        debug("travsersing node", node);

        if (
          typeof this.parent !== 'undefined' &&
          typeof node['@id'] === 'string'
        ) {
          var collection = self.collNamesByType[node['@type']];
          var path = self.path(collection, node['@id'])

          if (seen[path]) {
            return next();
          }

          return self.read(path, function (err, obj) {
            if (err) {
              queue.break();
              return cb(err);
            }

            seen[path] = true

            this.parent[this.key] = this.node = obj;

            queue.push(this);

            return next();
          }.bind(this));
        }
        else {
          return next();
        }
      }, function (newObj) {
        newObj['@id'] = id;

        return cb(null, newObj)
      });
    });
  },
  create: function () {
  },
  update: function () {
  },
  patch: function () {
  },
  remove: function () {
  },

});
