var Path = require('path');
var Url = require('url');
var traverseAsync = require('traverse-async').traverse;
var traverse = require('traverse');
var Class = require('es-class');
var each = require('async-each');
var extend = require('xtend');
var debug = require('debug')('fs-storage');

var config = require('config');

var stripSlashes = function (name) {
  return name.replace(/^\/|\/$/g, '');
};

var serialize = function serialize (obj) {
  return JSON.stringify(obj, null, 2);
};

var deserialize = function deserialize (str) {
  return JSON.parse(str);
};

module.exports = Class({

  constructor: function (options) {

    this.collection = options.collection || "";
    this.collections = options.collections || {};
    
    this.collNamesByType = {};
    Object.keys(this.collections).forEach(function (collName) {
      var collection = this.collections[collName];
      this.collNamesByType[collection.id] = collName;
    }.bind(this));

    this.fs = options.fs || require('fs');
    this.fsRoot = options.fsRoot || config.get('data.root');

    this.extname = options.extname || ".json";
    this.serialize = options.serialize || serialize;
    this.deserialize = options.deserialize || deserialize;
  },

  fullId: function (collection, id) {
    debug("fullId(", collection, id, ")")

    var fullId = Path.join(
      collection,
      id
    );

    debug("fullId() ->", fullId);
    return fullId;
  },

  path: function (fullId) {
    debug("path(", fullId, ")")

    var path = Path.join(
      this.fsRoot,
      fullId ? (fullId + this.extname) : ""
    );

    debug("path() ->", path);
    return path;
  },

  read: function (path, cb) {
    debug("read(", path, ")");
    this.fs.readFile(path, function (err, buf) {
      if (err) { return cb(err); }

      var str = buf.toString();
      debug("read raw", str);

      var obj = this.deserialize(str);

      debug("read() ->", obj);

      return cb(null, obj);
    }.bind(this));
  },

  write: {
  },

  find: function (params, cb) {
    var path = this.path(this.collection)
    return this.fs.readdir(path, function (err, dirList) {
      var ids = dirList.filter(function (name) {
        return Path.extname(name) === this.extname;
      }, this).map(function (name) {
        return Path.basename(name, this.extname);
      }, this);

      each(ids, function (id, next) {
        return this.get(id, params, next);
      }.bind(this), cb);
    }.bind(this));
  },

  get: function (id, params, cb) {
    debug("get", id, params);

    var seen = {};

    var self = this;
    var fullId = self.fullId(self.collection, id);
    var path = self.path(fullId);

    return self.read(path, function (err, initObj) {
      if (err) { return cb(err); }

      seen[path] = true;

      debug("traversing object", initObj);
      var queue = traverseAsync(initObj, function (node, next) {
        debug("travsersing node", node);

        if (
          typeof this.parent !== 'undefined' &&
          typeof node['@type'] === 'string' &&
          typeof node['@id'] === 'string'
        ) {
          var collection = self.collNamesByType[node['@type']];
          var fullId = self.fullId(collection, node['@id']);
          var path = self.path(fullId);

          if (seen[path]) {
            return next();
          }

          return self.read(path, function (err, obj) {
            if (err) {
              queue.break();
              return cb(err);
            }

            seen[path] = true;

            this.parent[this.key] = this.node = obj;

            queue.push(this);

            return next();
          }.bind(this));
        }
        else {
          return next();
        }
      }, function (newObj) {
        newObj['@id'] = fullId;

        // fix ids of leaves
        newObj = traverse(newObj).map(function () {

          if (
            typeof this.node === 'object' &&
            Object.keys(this.node).length == 2 &&
            typeof this.node['@id'] === 'string' &&
            typeof this.node['@type'] === 'string'
          ) {
            var collection = self.collNamesByType[this.node['@type']];
            var fullId = self.fullId(collection, this.node['@id']);

            this.update(extend(this.node, {
              '@id': fullId,
            }));
          };
        });

        return cb(null, newObj)
      });
    });
  },
  create: function () {
  },
  update: function () {
  },
  patch: function () {
  },
  remove: function () {
  },

});
