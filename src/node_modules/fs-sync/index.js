var Path = require('path')
var Url = require('url')
var each = require('async-each')
var extend = require('xtend')
var camelCase = require('camel-case')
var debug = require('debug')('holodex:fs-sync')

module.exports = function (opts) {
  debug("createSync(", opts, ")")

  if (!opts.location) {
    throw new Error("fs-sync expects location")
  }

  var self = {
    location: opts.location,
    codec: opts.codec || jsonCodec,
    fs: opts.fs || require('fs'),
  }

  debug("location", self.location, "prefix", self.prefix)

  return function (method, model, options) {
    debug("sync(", method, model, options, ")")

    if (method === "read" && model.isCollection) {
      readCollection(self, model, options, function (err, resp) {
        if (err && options.error) {
          debug("sync error", err, resp)
          return options.error(resp, 'error', err.message);
        }
        if (options.success) {
          debug("sync success", resp)
          return options.success(resp, 'success', resp)
        }
      })
    }
  }
}

var jsonCodec = {
  extname: '.json',
  serialize: function _serialize (obj) {
    return JSON.stringify(obj, null, 2)
  },
  deserialize: function _deserialize (str) {
    return JSON.parse(str)
  },
}

function stripSlashes (name) {
  return name.replace(/^\/|\/$/g, '')
}

function idToPath (self, id) {
  var path = Path.join(self.location, id)
  debug("idToPath(", id, ") ->", path)
  return path
}

function pathToId (self, path) {
  var id = Path.relative(self.location, path)
  debug("pathToId(", path, ") ->", id)
  return id
}

function readModel (self, model, options, cb) {
  debug('readModel(', model, options, ')')

  var modelPath = idToPath(self, model.id) +
    self.codec.extname

  self.fs.readFile(modelPath, function (err, buf) {
    if (err) { return cb(err) }

    var str = buf.toString()

    var obj = self.codec.deserialize(str)

    obj[model.idAttribute] = model.getId()

    debug('readModel() ->', obj)
    return cb(null, obj)
  })
}

function readCollection (self, collection, options, cb) {
  debug('readCollection(', collection, options, ')')

  var colId = camelCase(collection.collectionType)
  var colPath = idToPath(self, colId)

  getModelList(colPath, function (err, models) {
    if (err) { return cb(err); }
    each(models, function (model, next) {
      readModel(self, model, options, next)
    }, function (err, objs) {
      debug('readCollection() ->', err, objs)
      cb(err, objs)
    })
  })

  function getModelList (path, callback) {
    self.fs.readdir(colPath, function (err, dirList) {

      if (err) {
        // if directory not found
        if (err.code === "ENOENT") {
          return callback(null, [])
        }
        return callback(err)
      }

      var models = dirList
      .filter(function (name) {
        return Path.extname(name) === self.codec.extname
      })
      .map(function (name) {
        return Path.basename(name, self.codec.extname)
      })
      .map(function (modelName) {
        var Model = collection.model
        var modelId = pathToId(self, Path.join(colPath, modelName))
        
        var modelAttrs = {}
        modelAttrs[Model.prototype.idAttribute] = modelId

        return new Model(modelAttrs)
      })

      callback(null, models)
    })
  }
}
