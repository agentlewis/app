var Path = require('path')
var Url = require('url')
var each = require('async-each')
var extend = require('xtend')
var debug = require('debug')('fs-sync')

module.exports = function (opts) {
  debug("createSync(", opts, ")")

  if (!opts.location) {
    throw new Error("fs-sync expects location")
  }

  var self = {
    location: opts.location,
    prefix: opts.prefix || "",
    codec: opts.codec || jsonCodec,
    fs: opts.fs || require('fs'),
  }

  //debug("sync self", self)

  return function (method, model, options) {
    debug("sync(", method, model, options, ")")

    if (method === "read" && model.isCollection) {
      readCollection(self, model, options, function (err, resp) {
        if (err && options.error) {
          return options.error(resp, 'error', err.message);
        }
        if (options.success) {
          return options.success(resp, 'success', resp)
        }
      })
    }
  }
}

var jsonCodec = {
  extname: '.json',
  serialize: function _serialize (obj) {
    return JSON.stringify(obj, null, 2)
  },
  deserialize: function _deserialize (str) {
    return JSON.parse(str)
  },
}

function stripSlashes (name) {
  return name.replace(/^\/|\/$/g, '')
}

function urlToPath (self, url) {
  var prefixRe = new RegExp('^' + self.prefix)
  var id = url.replace(prefixRe, '')
  var path = Path.join(self.location, id)
  debug("urlToPath(", url, ") ->", path)
  return path
}

function pathToUrl (self, path) {
  var relativePath = Path.relative(self.location, path)
  var url = self.prefix + "/" + stripSlashes(relativePath)
  debug("pathToUrl(", path, ") ->", url)
  return url
}

function readModel (self, model, options, cb) {
  debug('readModel(', model, options, ')')

  var modelPath = urlToPath(self, model.url()) +
    self.codec.extname

  self.fs.readFile(modelPath, function (err, buf) {
    if (err) { return cb(err) }

    var str = buf.toString()

    var obj = self.codec.deserialize(str)

    obj[model.idAttribute] = model.getId()

    debug('readModel() ->', obj)
    return cb(null, obj)
  })
}

function readCollection (self, collection, options, cb) {
  debug('readCollection(', collection, options, ')')

  var colPath = urlToPath(self, collection.url())

  self.fs.readdir(colPath, function (err, dirList) {
    if (err) { return cb(err) }

    var models = dirList
    .filter(function (name) {
      return Path.extname(name) === self.codec.extname
    })
    .map(function (name) {
      return Path.basename(name, self.codec.extname)
    })
    .map(function (modelName) {
      var Model = collection.model
      var modelId = pathToUrl(self, Path.join(colPath, modelName))
      
      var modelAttrs = {}
      modelAttrs[Model.prototype.idAttribute] = modelId

      return new Model(modelAttrs)
    })

    each(models, function (model, next) {
      readModel(self, model, options, next)
    }, function (err, objs) {
      debug('readCollection() ->', err, objs)
      cb(err, objs)
    })
  })
}
